# NestJS 페이지네이션 구현 가이드

## Self-Check List (학습 확인용)

이 프로젝트의 핵심 내용을 마스터했는지 확인하기 위한 체크리스트입니다. 아래 내용을 보지 않고 구현할 수 있다면 이 문서는 졸업하셔도 좋습니다.

### 1. 요청 처리 (Request Handling)
- [ ] 쿼리 파라미터(`page`, `limit`)를 DTO에서 숫자로 자동 변환(`@Type`) [[참고](#요청-dto-패턴)]
- [ ] 잘못된 입력(음수, 과도한 limit)을 `ValidationPipe`로 차단 [[참고](#요청-dto-패턴)]
- [ ] 값이 없을 때 기본값(`default`)을 설정하여 방어 로직 구현 [[참고](#요청-dto-패턴)]

### 2. 응답 구조화 (Response Structuring)
- [ ] 전체 개수(`total`)를 받아 `totalPages`, `hasNextPage` 등 메타데이터 계산 유틸리티 구현 [[참고](#응답-dto-패턴)]
- [ ] 서비스 계층의 순수 객체(Interface 기반) 반환 및 컨트롤러 직렬화 구조 이해 [[참고](#아키텍처-패턴)]

### 3. 보안 및 직렬화 (Security & Serialization)
- [ ] `@Exclude()`가 동작하지 않는 원인(순수 객체 vs 인스턴스) 이해 [[참고](#응답-dto-패턴)]
- [ ] `plainToInstance`를 사용하여 응답 데이터를 인스턴스로 변환 [[참고](#응답-dto-패턴)]
- [ ] `ClassSerializerInterceptor` 전역 설정을 통한 민감 정보(`password`) 마스킹 [[참고](#응답-dto-패턴)]

### 4. Swagger 자동화 (Swagger Automation)
- [ ] 제네릭 타입(`PaginatedResultDto<T>`)의 Swagger 소실(Erasure) 현상 이해 [[참고](#swagger-문서화)]
- [ ] `ApiExtraModels`, `allOf`, `$ref`를 사용한 동적 스키마 생성 커스텀 데코레이터 구현 [[참고](#swagger-문서화)]
- [ ] 데이터 구조(`ItemDto`) 변경 시 Swagger 문서 자동 업데이트 설정 [[참고](#swagger-문서화)]

---

## 목차
1. [프로젝트 개요](#프로젝트-개요)
2. [DTO vs Interface 사용 전략](#dto-vs-interface-사용-전략)
3. [Swagger 문서화](#swagger-문서화)
4. [요청 DTO 패턴](#요청-dto-패턴)
5. [응답 DTO 패턴](#응답-dto-패턴)
6. [아키텍처 패턴](#아키텍처-패턴)

---

## 프로젝트 개요

NestJS에서 페이지네이션을 구현하면서 DTO와 Interface의 올바른 사용법, Swagger 문서화, 그리고 계층별 데이터 변환 패턴을 정리한 프로젝트입니다.

### 주요 학습 내용
- 제네릭 타입의 Swagger 문서화 방법
- DTO와 Interface의 역할 분리
- 응답 데이터의 안전한 변환 (plainToInstance)
- ClassSerializerInterceptor를 통한 민감 정보 제거

---

## DTO vs Interface 사용 전략

### 기본 원칙

| 구분 | 사용 위치 | 목적 |
|------|----------|------|
| **DTO** | 컨트롤러 계층 | Swagger 문서화, 유효성 검사, 직렬화 |
| **Interface** | 서비스, 유틸리티 계층 | 타입 안정성, 계약 정의 |

### 구현 패턴

```typescript
// 1. Interface 정의 (타입 계약)
export interface PaginationOptions {
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: 'ASC' | 'DESC';
}

// 2. DTO 구현 (컨트롤러 전용)
export class PaginationOptionsDto implements PaginationOptions {
  @ApiProperty({ description: '페이지', default: 1 })
  @IsInt()
  @Min(1)
  @IsOptional()
  page: number = 1;

  @ApiProperty({ description: '리미트', default: 10 })
  @IsInt()
  @Min(1)
  @Max(50)
  @IsOptional()
  limit: number = 10;

  // ...
}
```

**왜 이렇게?**
- Interface: 서비스 레이어에서 데이터 구조만 정의
- DTO: 컨트롤러에서 검증 + 문서화 + 기본값 설정

---

## Swagger 문서화

### 문제: 제네릭 타입의 런타임 소실

TypeScript의 제네릭 타입 정보는 런타임에 사라집니다.

```typescript
// ❌ Swagger가 PageItemDto를 인식하지 못함
async getPage(): Promise<PaginatedResultDto<PageItemDto>> {
  // 컴파일 후 → Promise<PaginatedResultDto>
  // PageItemDto 타입 정보 소실!
}
```

### 해결: 커스텀 데코레이터

제네릭 타입을 명시적으로 Swagger에 전달하는 데코레이터를 구현합니다.

```typescript
export const ApiPaginatedResponse = <TModel extends Type<any>>(model: TModel) => {
  return applyDecorators(
    // 1. Swagger 스키마에 모델 등록
    ApiExtraModels(PaginatedResultDto, model),

    // 2. 응답 스키마 정의
    ApiOkResponse({
      schema: {
        allOf: [
          // 기본 PaginatedResultDto 구조 참조
          { $ref: getSchemaPath(PaginatedResultDto) },

          // items 배열의 구체적 타입 오버라이드
          {
            properties: {
              items: {
                type: 'array',
                items: { $ref: getSchemaPath(model) },
              },
            },
          },
        ],
      },
    }),
  );
};
```

**핵심 개념:**
- `applyDecorators`: 여러 데코레이터를 하나로 합침
- `ApiExtraModels`: Swagger에 사용할 모델을 미리 등록
- `allOf`: OpenAPI의 스키마 조합 (상속 개념)
- `$ref`: 등록된 스키마를 참조
- `getSchemaPath`: 클래스를 Swagger 스키마 경로로 변환

### 사용 예시

```typescript
@Get('/page')
@ApiPaginatedResponse(PageItemDto)  // ✅ 간단하게 사용
async getPage(
  @Query() query: PaginationOptionsDto,
): Promise<PaginatedResultDto<PageItemDto>> {
  // ...
}
```

**상세 설명:** [docs/페이지네이션_응답_데코레이터_가이드.md](docs/페이지네이션_응답_데코레이터_가이드.md)

---

## 요청 DTO 패턴

### 역할

1. **유효성 검사** (`class-validator`)
2. **기본값 지정**
3. **타입 변환** (`class-transformer`)
4. **Swagger 문서화** (`@nestjs/swagger`)

### 구현 예시

```typescript
export class PaginationOptionsDto implements PaginationOptions {
  @ApiPropertyOptional({
    description: '페이지 번호',
    example: 1,
    default: 1,
    required: false,
  })
  @Type(() => Number)  // 문자열 → 숫자 자동 변환
  @IsInt({ message: '페이지는 정수여야 합니다.' })
  @Min(1, { message: '페이지는 1 이상이어야 합니다.' })
  @IsOptional()
  page: number = 1;

  @ApiPropertyOptional({
    description: '페이지당 항목 수',
    example: 10,
    default: 10,
    required: false,
  })
  @Type(() => Number)
  @IsInt({ message: '리미트는 정수여야 합니다.' })
  @Min(1, { message: '리미트는 1 이상이어야 합니다.' })
  @Max(50, { message: '리미트는 50 이하여야 합니다.' })
  @IsOptional()
  limit: number = 10;
}
```

### 자동 변환 과정

```
HTTP 요청: ?page=2&limit=20
    ↓
@Type(() => Number) 적용
    ↓
{ page: 2, limit: 20 }  // 숫자로 변환됨
    ↓
ValidationPipe 검증 (@IsInt, @Min, @Max)
    ↓
컨트롤러로 전달
```

---

## 응답 DTO 패턴

### 주요 특징

| 특징 | 설명 |
|------|------|
| **ValidationPipe 미동작** | 응답 데이터는 유효성 검증 안 됨 |
| **Swagger 문서화** | `@ApiProperty()`로 응답 스키마 정의 |
| **민감 정보 제거** | `ClassSerializerInterceptor` + 데코레이터 |
| **클래스 변환 필수** | `plainToInstance()`로 변환해야 데코레이터 동작 |

### 민감 정보 제거 패턴

#### 1. 응답 DTO 정의

```typescript
import { Exclude } from 'class-transformer';

export class PageItemDto implements PageItem {
  @ApiProperty({ description: 'ID', example: 1 })
  id: number;

  @ApiProperty({ description: '데이터', example: 'Sample data' })
  data: string;

  @Exclude()  // ⚠️ Swagger에는 표시되지만, 응답에서 제외됨
  password: string;
}
```

#### 2. 컨트롤러에서 변환

```typescript
import { plainToInstance } from 'class-transformer';

@Get('/page')
async getPage(): Promise<PaginatedResultDto<PageItemDto>> {
  const { items, total } = await this.appService.findPage();

  return {
    items: plainToInstance(PageItemDto, items),  // ✅ 클래스로 변환
    meta: PaginationUtil.createMeta(total, { page: 1, limit: 10 }),
  };
}
```

#### 3. Global Interceptor 등록 (main.ts)

```typescript
import { ClassSerializerInterceptor } from '@nestjs/common';
import { Reflector } from '@nestjs/core';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // ✅ ClassSerializerInterceptor 등록
  app.useGlobalInterceptors(
    new ClassSerializerInterceptor(app.get(Reflector)),
  );

  await app.listen(3000);
}
```

### 변환 과정

```
서비스 반환: Plain Object
  { id: 1, data: 'test', password: 'secret' }
    ↓
plainToInstance(PageItemDto, items)
    ↓
PageItemDto 클래스 인스턴스
    ↓
ClassSerializerInterceptor 적용
    ↓
최종 응답 (password 제외됨)
  { id: 1, data: 'test' }
```

### class-transformer 데코레이터

| 데코레이터 | 용도 | 예시 |
|-----------|------|------|
| `@Exclude()` | 필드를 응답에서 제외 | 비밀번호, 내부 ID |
| `@Expose()` | 계산된 필드 추가 | fullName = firstName + lastName |
| `@Transform()` | 값 변환 | 날짜 포맷, 대소문자 변환 |

**예시:**

```typescript
export class UserDto {
  @Exclude()
  password: string;

  @Expose()
  get fullName(): string {
    return `${this.firstName} ${this.lastName}`;
  }

  @Transform(({ value }) => value.toUpperCase())
  username: string;

  @Transform(({ value }) => new Date(value).toISOString())
  createdAt: Date;
}
```

---

## 아키텍처 패턴

### 계층별 역할 분리

```
┌─────────────────────────────────────────────┐
│ Controller (컨트롤러)                        │
│ - DTO 사용 (요청/응답)                       │
│ - Swagger 문서화                            │
│ - plainToInstance()로 변환                  │
└─────────────┬───────────────────────────────┘
              │
              ↓
┌─────────────────────────────────────────────┐
│ Service (서비스)                             │
│ - Interface 사용                            │
│ - Plain Object 반환                         │
│ - 비즈니스 로직 처리                         │
└─────────────┬───────────────────────────────┘
              │
              ↓
┌─────────────────────────────────────────────┐
│ Repository/Database                         │
│ - Plain Object 반환                         │
└─────────────────────────────────────────────┘
```

### 데이터 흐름 예시

```typescript
// 1. 컨트롤러 (DTO 사용)
@Controller()
export class AppController {
  @Get('/page')
  @ApiPaginatedResponse(PageItemDto)
  async getPage(
    @Query() query: PaginationOptionsDto,  // DTO (요청)
  ): Promise<PaginatedResultDto<PageItemDto>> {  // DTO (응답)
    // 서비스 호출 (Interface 전달)
    const { items, total } = await this.service.findPage(query);

    // Plain Object → DTO 클래스 변환
    return {
      items: plainToInstance(PageItemDto, items),
      meta: PaginationUtil.createMeta(total, query),
    };
  }
}

// 2. 서비스 (Interface 사용, Plain Object 반환)
@Injectable()
export class AppService {
  async findPage(
    options: PaginationOptions  // Interface
  ): Promise<{ items: PageItem[]; total: number }> {  // Interface
    // Plain Object 반환
    return {
      items: [
        { id: 1, data: 'test', password: 'secret' },
      ],
      total: 1,
    };
  }
}
```

### 핵심 원칙

1. **DTO는 컨트롤러 전용**
   - Swagger 문서화 필요
   - 유효성 검사 필요
   - 직렬화 제어 필요

2. **Interface는 내부 계층 전용**
   - 서비스, 유틸리티, 레포지토리
   - 타입 안정성만 필요
   - 런타임 동작 불필요

3. **DTO는 Interface를 구현**
   ```typescript
   export class PaginationOptionsDto implements PaginationOptions {
     // DTO 전용 데코레이터 추가
   }
   ```

4. **서비스는 Plain Object 반환**
   - DTO 클래스 인스턴스 생성 책임은 컨트롤러
   - 서비스는 순수한 데이터 반환

5. **컨트롤러에서 변환**
   ```typescript
   plainToInstance(PageItemDto, plainObject)
   ```

---

## 참고 자료

- [페이지네이션 응답 데코레이터 가이드](docs/페이지네이션_응답_데코레이터_가이드.md)
- [NestJS 공식 문서 - Serialization](https://docs.nestjs.com/techniques/serialization)
- [NestJS 공식 문서 - OpenAPI](https://docs.nestjs.com/openapi/introduction)
- [class-transformer GitHub](https://github.com/typestack/class-transformer)
- [class-validator GitHub](https://github.com/typestack/class-validator)

---

## 프로젝트 구조

```
src/
├── common/
│   └── decorators/
│       └── api-paginated-response.decorator.ts  # 커스텀 Swagger 데코레이터
├── dto/
│   ├── pagination.dto.ts                        # 페이지네이션 DTO
│   └── page-item.dto.ts                         # 응답 아이템 DTO
├── types/
│   └── pagination.type.ts                       # Interface 정의
├── transform/
│   └── transform.interceptor.ts                 # 응답 포맷 인터셉터
├── pagination.util.ts                           # 페이지네이션 유틸리티
├── app.controller.ts                            # 컨트롤러
├── app.service.ts                               # 서비스
└── main.ts                                      # 진입점

docs/
└── 페이지네이션_응답_데코레이터_가이드.md       # 상세 가이드
```
