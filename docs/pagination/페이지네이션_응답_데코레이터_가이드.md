# ApiPaginatedResponse 커스텀 데코레이터 가이드

## 개요

`ApiPaginatedResponse`는 NestJS에서 페이지네이션 응답을 Swagger 문서에 자동으로 등록하는 재사용 가능한 커스텀 데코레이터입니다.

## 위치

```
src/common/decorators/api-paginated-response.decorator.ts
```

## 전체 코드

```typescript
import { applyDecorators, Type } from '@nestjs/common';
import { ApiExtraModels, ApiOkResponse, getSchemaPath } from '@nestjs/swagger';
import { PaginatedResultDto } from '../../dto/pagination.dto';

export const ApiPaginatedResponse = <TModel extends Type<any>>(model: TModel) => {
  return applyDecorators(
    ApiExtraModels(PaginatedResultDto, model),
    ApiOkResponse({
      schema: {
        allOf: [
          { $ref: getSchemaPath(PaginatedResultDto) },
          {
            properties: {
              items: {
                type: 'array',
                items: { $ref: getSchemaPath(model) },
              },
            },
          },
        ],
      },
    }),
  );
};
```

---

## 핵심 개념 설명

### 1. 제네릭 타입 매개변수

```typescript
<TModel extends Type<any>>(model: TModel)
```

- **`TModel`**: 제네릭 타입 매개변수
- **`Type<any>`**: NestJS의 클래스 타입
- **`model`**: 실제 전달받을 DTO 클래스 (예: `PageItemDto`)

**사용 예시:**
```typescript
@ApiPaginatedResponse(PageItemDto)
//                     ^^^^^^^^^^^ TModel = PageItemDto
```

### 2. `applyDecorators()` - 데코레이터 합성

```typescript
return applyDecorators(
  ApiExtraModels(PaginatedResultDto, model),
  ApiOkResponse({ schema: { ... } }),
);
```

**역할:**
- NestJS의 유틸리티 함수
- **여러 데코레이터를 하나로 합침**
- 다음과 같이 쓰는 것과 동일:
  ```typescript
  @ApiExtraModels(PaginatedResultDto, PageItemDto)
  @ApiOkResponse({ schema: { ... } })
  ```

### 3. `ApiExtraModels()` - 스키마 등록

```typescript
ApiExtraModels(PaginatedResultDto, model)
```

**역할:**
- Swagger에게 "이 모델들을 문서에 포함시켜라"라고 알려줌
- `PaginatedResultDto`와 `model`(예: `PageItemDto`)을 Swagger 스키마에 등록

**왜 필요한가?**
- Swagger는 직접 참조되지 않은 모델을 자동으로 인식하지 못함
- `allOf`, `$ref`로 참조할 모델을 미리 등록해야 함

### 4. `ApiOkResponse()` - 응답 스키마 정의

```typescript
ApiOkResponse({
  schema: {
    allOf: [
      { $ref: getSchemaPath(PaginatedResultDto) },
      {
        properties: {
          items: {
            type: 'array',
            items: { $ref: getSchemaPath(model) },
          },
        },
      },
    ],
  },
})
```

#### 4-1. `allOf` - 스키마 조합

OpenAPI의 `allOf`는 **여러 스키마를 합치는** 기능입니다.

```typescript
allOf: [
  { $ref: getSchemaPath(PaginatedResultDto) },  // ① 기본 구조
  {
    properties: {
      items: { ... }  // ② items 타입 오버라이드
    },
  },
]
```

**생성되는 스키마:**
```json
{
  "items": [],      // ← ②에서 구체적 타입으로 오버라이드됨
  "meta": {
    "total": 100,
    "page": 1,
    "limit": 10,
    "totalPages": 10,
    "hasNextPage": true,
    "hasPreviousPage": false,
    "nextPage": 2,
    "previousPage": null
  }
}
```

#### 4-2. `$ref` & `getSchemaPath()` - 스키마 참조

```typescript
{ $ref: getSchemaPath(PaginatedResultDto) }
{ $ref: getSchemaPath(model) }
```

- **`getSchemaPath()`**: 모델 클래스를 Swagger 스키마 경로로 변환
- **`$ref`**: OpenAPI의 참조 문법

**변환 예시:**
```typescript
getSchemaPath(PaginatedResultDto)
// → "#/components/schemas/PaginatedResultDto"

getSchemaPath(PageItemDto)
// → "#/components/schemas/PageItemDto"
```

#### 4-3. `items` 타입 오버라이드

```typescript
properties: {
  items: {
    type: 'array',
    items: { $ref: getSchemaPath(model) },
  },
}
```

**의미:**
- `items` 필드를 **구체적인 배열 타입**으로 재정의
- `items: T[]`에서 `T`를 `PageItemDto`로 구체화

**결과:**
```json
{
  "items": [
    {
      "id": 1,
      "data": "Sample data"
    }
  ]
}
```

---

## 사용 방법

### Before (데코레이터 없이)

```typescript
@Get('/page')
@ApiExtraModels(PaginatedResultDto, PageItemDto)
@ApiOkResponse({
  schema: {
    allOf: [
      { $ref: getSchemaPath(PaginatedResultDto) },
      {
        properties: {
          items: {
            type: 'array',
            items: { $ref: getSchemaPath(PageItemDto) },
          },
        },
      },
    ],
  },
})
async getPage(@Query() query: PaginationOptionsDto): Promise<PaginatedResultDto<PageItemDto>> {
  // ...
}
```

### After (데코레이터 사용)

```typescript
@Get('/page')
@ApiPaginatedResponse(PageItemDto)
async getPage(@Query() query: PaginationOptionsDto): Promise<PaginatedResultDto<PageItemDto>> {
  // ...
}
```

---

## 왜 이 데코레이터가 필요한가?

### 문제: TypeScript 제네릭 타입은 런타임에 사라짐

```typescript
async getPage(): Promise<PaginatedResultDto<PageItemDto>> {
  // TypeScript 컴파일 후 → Promise<PaginatedResultDto>
  // PageItemDto 타입 정보가 런타임에 소실됨!
}
```

### Swagger의 한계

- **요청(Request) DTO**: `@Query()`, `@Body()`, `@Param()`에 사용된 DTO는 **자동 인식** ✅
  ```typescript
  async getPage(@Query() query: PaginationOptionsDto) {
    // PaginationOptionsDto는 자동으로 Swagger에 표시됨
  }
  ```

- **응답(Response) DTO**: 제네릭 타입 정보는 런타임에 소실되어 **명시 필요** ⚠️
  ```typescript
  async getPage(): Promise<PaginatedResultDto<PageItemDto>> {
    // PageItemDto 타입 정보를 Swagger가 알 수 없음!
  }
  ```

### 해결: 명시적 스키마 선언

`@ApiPaginatedResponse(PageItemDto)` 데코레이터를 사용하여:
1. 제네릭 타입 정보를 런타임에 전달
2. Swagger에 구체적인 스키마 등록
3. `items` 배열의 정확한 타입 문서화

---

## 생성되는 Swagger 문서

```json
{
  "responses": {
    "200": {
      "description": "",
      "content": {
        "application/json": {
          "schema": {
            "allOf": [
              {
                "$ref": "#/components/schemas/PaginatedResultDto"
              },
              {
                "properties": {
                  "items": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/PageItemDto"
                    }
                  }
                }
              }
            ]
          }
        }
      }
    }
  }
}
```

---

## 구성 요소 정리

| 요소 | 역할 |
|------|------|
| `applyDecorators` | 여러 데코레이터를 하나로 합침 |
| `ApiExtraModels` | Swagger에 모델 등록 |
| `ApiOkResponse` | 200 응답 스키마 정의 |
| `allOf` | 여러 스키마 조합 (상속 개념) |
| `$ref` | 등록된 스키마 참조 |
| `getSchemaPath` | 클래스 → 스키마 경로 변환 |

---

## 장점

✅ **제네릭 타입 문제 해결**
- TypeScript의 타입 소실 문제를 우회
- 런타임에 정확한 타입 정보 전달

✅ **재사용 가능**
- 다양한 엔티티에 동일한 패턴 적용 가능
- 코드 중복 제거

✅ **Swagger 문서 자동 생성**
- 정확한 API 문서 자동 생성
- 프론트엔드와의 계약 명확화

✅ **타입 안정성**
- 컴파일 타임 타입 체킹
- 런타임 스키마 검증

---

## 실제 사용 예시

```typescript
// src/app.controller.ts
import { ApiPaginatedResponse } from './common/decorators/api-paginated-response.decorator';
import { PageItemDto } from './dto/page-item.dto';

@Controller()
export class AppController {
  @Get('/page')
  @ApiPaginatedResponse(PageItemDto)
  async getPage(
    @Query() query: PaginationOptionsDto,
  ): Promise<PaginatedResultDto<PageItemDto>> {
    const { items, total } = await this.appService.findPage(
      query.page,
      query.limit,
    );
    const meta = PaginationUtil.createMeta(total, {
      page: query.page,
      limit: query.limit,
    });

    return {
      items: plainToInstance(PageItemDto, items),
      meta,
    };
  }
}
```

---

## 관련 파일

- `src/common/decorators/api-paginated-response.decorator.ts` - 데코레이터 구현
- `src/dto/pagination.dto.ts` - PaginatedResultDto 정의
- `src/dto/page-item.dto.ts` - 응답 DTO 예시
- `src/app.controller.ts` - 사용 예시
