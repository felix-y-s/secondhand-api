# 테스트 트랜잭션 자동 롤백 설정 가이드

## 개요

PostgreSQL + Prisma 환경에서 각 테스트를 자동으로 트랜잭션 내에서 실행하고, 테스트 종료 시 자동 롤백하여 데이터를 정리하는 방법입니다.

## 설정 방법

### 1. 테스트 헬퍼 작성

**src/test/test-transaction-helper.ts**:
```typescript
import { PrismaClient } from '@prisma/client';

/**
 * 각 테스트를 트랜잭션 내에서 실행하고 자동 롤백
 */
export function runInTransaction(callback: (tx: any) => Promise<void>) {
  return async () => {
    const prisma = new PrismaClient();

    try {
      await prisma.$transaction(async (tx) => {
        await callback(tx);

        // 의도적으로 에러를 발생시켜 롤백 강제
        throw new Error('ROLLBACK');
      });
    } catch (error) {
      // 'ROLLBACK' 에러는 무시 (의도적 롤백)
      if (error.message !== 'ROLLBACK') {
        throw error;
      }
    } finally {
      await prisma.$disconnect();
    }
  };
}
```

### 2. Jest Global Setup (권장)

**src/test/jest-transaction-setup.ts**:
```typescript
import { PrismaClient } from '@prisma/client';

let prisma: PrismaClient;
let transactionClient: any;

// 각 테스트 전에 트랜잭션 시작
beforeEach(async () => {
  prisma = new PrismaClient();

  // 트랜잭션 시작 및 클라이언트 저장
  await prisma.$transaction(async (tx) => {
    transactionClient = tx;

    // 테스트 실행 대기 (트랜잭션 내에서)
    // 실제로는 jest의 테스트 실행을 기다림
  });
});

// 각 테스트 후 자동 롤백
afterEach(async () => {
  // 트랜잭션은 자동으로 롤백됨 (정상 완료되지 않았으므로)
  await prisma.$disconnect();
});
```

### 3. Prisma Extension 사용 (최신 방법)

**src/test/prisma-test-extension.ts**:
```typescript
import { PrismaClient } from '@prisma/client';

export const createTestPrismaClient = () => {
  const prisma = new PrismaClient();

  return prisma.$extends({
    client: {
      // 모든 쿼리를 트랜잭션으로 래핑
      async $executeInTransaction<T>(fn: (client: PrismaClient) => Promise<T>): Promise<T> {
        let result: T;

        try {
          await prisma.$transaction(async (tx) => {
            result = await fn(tx as PrismaClient);
            // 강제 롤백
            throw new Error('ROLLBACK');
          });
        } catch (error) {
          if (error.message !== 'ROLLBACK') {
            throw error;
          }
        }

        return result!;
      },
    },
  });
};
```

### 4. 테스트에서 사용

**기존 방식 (수동 정리)**:
```typescript
describe('Users API', () => {
  afterEach(async () => {
    // 수동 정리
    await prisma.user.deleteMany({});
  });

  it('사용자 생성', async () => {
    const user = await prisma.user.create({ data: {...} });
    expect(user).toBeDefined();
  });
});
```

**자동 롤백 방식**:
```typescript
describe('Users API', () => {
  let testPrisma: ReturnType<typeof createTestPrismaClient>;

  beforeEach(() => {
    testPrisma = createTestPrismaClient();
  });

  afterEach(async () => {
    await testPrisma.$disconnect();
    // 자동 롤백됨 - 정리 코드 불필요!
  });

  it('사용자 생성', async () => {
    await testPrisma.$executeInTransaction(async (tx) => {
      const user = await tx.user.create({ data: {...} });
      expect(user).toBeDefined();
    });
    // 테스트 종료 시 자동 롤백
  });
});
```

## 장단점

### ✅ 장점
- 테스트 격리 자동 보장
- 정리 코드 불필요
- 테스트 속도 향상 (DELETE 쿼리 불필요)
- 실수로 데이터 남을 가능성 제거

### ❌ 단점
- 설정 복잡도 증가
- 트랜잭션 내에서만 작동 (외부 시스템과 연동 불가)
- E2E 테스트에서는 제약 있음 (HTTP 요청은 트랜잭션 밖)

## 프로젝트 적용 여부

**현재 프로젝트**: 수동 정리 방식 사용
- 이유: E2E 테스트 중심, HTTP 요청 기반
- 자동 롤백은 단위 테스트에 더 적합

**권장 사항**:
- **단위 테스트**: 자동 롤백 사용
- **E2E 테스트**: 수동 정리 사용 (현재 방식 유지)
