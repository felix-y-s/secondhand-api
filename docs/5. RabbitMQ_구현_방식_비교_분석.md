# RabbitMQ 구현 방식 비교 분석

## 📋 문서 정보

- **프로젝트**: 중고거래사이트 백엔드 API
- **작성일**: 2025-10-15
- **목적**: NestJS Microservices vs 직접 AMQP 라이브러리 비교 분석

---

## 🎯 결론 먼저 보기

### ✅ 최종 권장: 직접 AMQP 라이브러리 (amqplib) 사용

**핵심 이유:**
1. **Saga 패턴 구현**: 복잡한 분산 트랜잭션 필수
2. **거래 무결성**: 메시지 손실 방지 및 순서 보장 필수
3. **프로덕션 안정성**: 재연결, Dead Letter Queue 세밀한 제어
4. **성능 최적화**: 대용량 이벤트 처리 및 우선순위 큐

---

## 📊 상세 비교표

| 항목 | NestJS Microservices | 직접 AMQP (amqplib) | 중요도 |
|------|---------------------|---------------------|--------|
| **개발 속도** | ✅ 빠름 | ⚠️ 느림 | ⭐⭐ |
| **NestJS 통합** | ✅ 완벽 | ⚠️ 수동 | ⭐⭐ |
| **RabbitMQ 기능** | ⚠️ 제한적 | ✅ 완전 | ⭐⭐⭐⭐⭐ |
| **성능 최적화** | ⚠️ 제한적 | ✅ 완전 제어 | ⭐⭐⭐⭐ |
| **Saga 패턴** | ❌ 어려움 | ✅ 완벽 지원 | ⭐⭐⭐⭐⭐ |
| **Dead Letter Queue** | ⚠️ 제한적 | ✅ 완전 제어 | ⭐⭐⭐⭐⭐ |
| **메시지 순서 보장** | ⚠️ 제한적 | ✅ 완전 제어 | ⭐⭐⭐⭐⭐ |
| **우선순위 큐** | ❌ 지원 안 함 | ✅ 지원 | ⭐⭐⭐⭐ |
| **재연결 로직** | ⚠️ 기본 제공 | ✅ 완전 제어 | ⭐⭐⭐⭐ |
| **프로덕션 안정성** | ⚠️ 제한적 | ✅ 높음 | ⭐⭐⭐⭐⭐ |
| **학습 곡선** | ✅ 낮음 | ⚠️ 높음 | ⭐⭐ |
| **유지보수성** | ✅ 간단 | ⚠️ 복잡 | ⭐⭐⭐ |

---

## 🔍 방식 1: NestJS Microservices

### 개요
`@nestjs/microservices` 패키지를 사용한 추상화된 메시지 브로커 통합

### 장점

#### 1. NestJS 생태계 완벽 통합 ✅
```typescript
// 데코레이터 기반 간단한 구현
@Controller()
export class OrdersController {
  @EventPattern('order.created')
  handleOrderCreated(@Payload() data: OrderCreatedEvent) {
    // 이벤트 처리
  }

  @MessagePattern({ cmd: 'get-order' })
  getOrder(@Payload() orderId: number) {
    // 요청-응답 패턴
    return this.ordersService.findOne(orderId);
  }
}
```

#### 2. 빠른 개발 속도 ⚡
- 보일러플레이트 코드 최소화
- 설정 간단
- 프로토타이핑에 최적

#### 3. Transport 전환 용이 🔄
```typescript
// RabbitMQ → Kafka 전환이 쉬움
// Transport만 변경하면 됨
Transport.RMQ // RabbitMQ
Transport.KAFKA // Kafka
Transport.REDIS // Redis
```

### 단점

#### 1. RabbitMQ 고급 기능 제한 ⚠️
- Exchange 타입 제한 (주로 fanout, topic만)
- 메시지 우선순위 설정 불가
- TTL, 메시지 확인(ACK) 세밀한 제어 어려움
- Dead Letter Exchange 커스터마이징 제한

#### 2. Saga 패턴 구현 어려움 ❌
```typescript
// Saga 보상 트랜잭션 구현이 매우 복잡
// 순서 보장, 재시도, 롤백 로직 구현 제한적
```

#### 3. 성능 제한 📉
- 추상화 레이어 오버헤드
- 커넥션/채널 풀링 제어 불가
- Prefetch 설정 제한적
- 대용량 메시지 처리 최적화 어려움

#### 4. 디버깅 복잡도 🐛
- 내부 동작 블랙박스
- 문제 발생 시 원인 파악 어려움
- RabbitMQ 관리 UI와 연동 제한적

### 적합한 경우
- 간단한 이벤트 발행/구독
- 프로토타입 개발
- RabbitMQ 고급 기능 불필요
- 빠른 개발 속도 우선

---

## 🔍 방식 2: 직접 AMQP 라이브러리 (amqplib)

### 개요
`amqplib` + `amqp-connection-manager`를 사용한 직접 제어

### 장점

#### 1. RabbitMQ 모든 기능 활용 ✅
```typescript
// Exchange 타입 자유 선택
channel.assertExchange('orders', 'topic', { durable: true });

// 우선순위 큐
channel.assertQueue('priority-queue', {
  durable: true,
  maxPriority: 10
});

// 메시지 우선순위 설정
channel.publish('orders', 'order.created', buffer, {
  priority: 8,
  persistent: true,
  expiration: '60000' // TTL
});
```

#### 2. Dead Letter Queue 완벽 제어 💀
```typescript
// Dead Letter Exchange 설정
channel.assertQueue('orders-queue', {
  durable: true,
  deadLetterExchange: 'orders-dlx',
  deadLetterRoutingKey: 'failed',
  messageTtl: 3600000, // 1시간
  maxLength: 10000
});

// DLQ 처리
channel.consume('orders-dlq', (msg) => {
  // 재시도 로직, 로깅, 알림
  const retryCount = msg.properties.headers['x-retry-count'] || 0;

  if (retryCount < 3) {
    // 재시도
    channel.publish('orders', 'order.created', msg.content, {
      headers: { 'x-retry-count': retryCount + 1 }
    });
  } else {
    // 영구 실패 처리
    logger.error('Message permanently failed', msg);
  }
});
```

#### 3. Saga 패턴 완벽 구현 🎯
```typescript
// 분산 트랜잭션 Saga 구현
class OrderSaga {
  async execute(orderId: number) {
    try {
      // 1. 주문 생성
      await this.publishEvent('order.created', { orderId });

      // 2. 재고 확인
      await this.publishEvent('inventory.reserve', { orderId });

      // 3. 결제 처리
      await this.publishEvent('payment.process', { orderId });

      // 4. 배송 시작
      await this.publishEvent('shipment.start', { orderId });

    } catch (error) {
      // 보상 트랜잭션 (Compensating Transaction)
      await this.compensate(orderId);
    }
  }

  async compensate(orderId: number) {
    // 역순으로 롤백
    await this.publishEvent('shipment.cancel', { orderId });
    await this.publishEvent('payment.refund', { orderId });
    await this.publishEvent('inventory.release', { orderId });
    await this.publishEvent('order.cancel', { orderId });
  }
}
```

#### 4. 성능 최적화 ⚡
```typescript
// Prefetch 설정으로 처리량 최적화
channel.prefetch(10); // 한 번에 10개 메시지만 처리

// 배치 처리
const messages = [];
channel.consume('batch-queue', (msg) => {
  messages.push(msg);

  if (messages.length >= 100) {
    // 100개씩 배치 처리
    processBatch(messages);
    messages.forEach(m => channel.ack(m));
    messages.length = 0;
  }
});

// 커넥션 풀링
const connectionManager = amqp.connect(['amqp://localhost'], {
  heartbeatIntervalInSeconds: 30,
  reconnectTimeInSeconds: 1
});
```

#### 5. 재연결 로직 완전 제어 🔄
```typescript
// amqp-connection-manager 사용
const connection = amqp.connect(['amqp://localhost'], {
  heartbeatIntervalInSeconds: 30,
  reconnectTimeInSeconds: 1
});

connection.on('connect', () => {
  logger.info('Connected to RabbitMQ');
});

connection.on('disconnect', (err) => {
  logger.error('Disconnected from RabbitMQ', err);
  // 커스텀 재연결 로직
});

// Circuit Breaker 패턴 적용
class RabbitMQCircuitBreaker {
  private failures = 0;
  private state: 'CLOSED' | 'OPEN' | 'HALF_OPEN' = 'CLOSED';

  async execute(operation: () => Promise<void>) {
    if (this.state === 'OPEN') {
      throw new Error('Circuit breaker is OPEN');
    }

    try {
      await operation();
      this.onSuccess();
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  private onSuccess() {
    this.failures = 0;
    this.state = 'CLOSED';
  }

  private onFailure() {
    this.failures++;
    if (this.failures >= 5) {
      this.state = 'OPEN';
      setTimeout(() => {
        this.state = 'HALF_OPEN';
      }, 60000); // 1분 후 반개방
    }
  }
}
```

### 단점

#### 1. 개발 복잡도 증가 ⚠️
- 보일러플레이트 코드 많음
- 채널 관리, 재연결 로직 직접 구현
- 에러 핸들링 복잡

#### 2. NestJS 통합 수동 작업 🔧
```typescript
// 의존성 주입 수동 설정
@Module({
  providers: [
    {
      provide: 'RABBITMQ_CONNECTION',
      useFactory: () => {
        return amqp.connect(['amqp://localhost']);
      },
    },
    RabbitMQService,
  ],
  exports: ['RABBITMQ_CONNECTION', RabbitMQService],
})
export class RabbitMQModule {}
```

#### 3. 학습 곡선 📚
- AMQP 프로토콜 이해 필요
- RabbitMQ 개념 (Exchange, Queue, Binding) 깊은 이해
- 디버깅 시간 증가

### 적합한 경우
- **Saga 패턴 분산 트랜잭션** ⭐⭐⭐⭐⭐
- **거래 무결성 중요** ⭐⭐⭐⭐⭐
- **메시지 손실 방지 필수** ⭐⭐⭐⭐⭐
- **우선순위 큐 필요** ⭐⭐⭐⭐
- **대용량 메시지 처리** ⭐⭐⭐⭐
- **프로덕션 안정성 우선** ⭐⭐⭐⭐⭐

---

## 🎯 중고거래 플랫폼 요구사항 분석

### 1. Saga 패턴 분산 트랜잭션 ⭐⭐⭐⭐⭐
```
주문 생성 → 재고 확인 → 결제 처리 → 배송 시작
   ↓           ↓           ↓           ↓
 성공        성공        실패        취소
   ↓           ↓           ↓           ↓
                    보상 트랜잭션 시작
                         ↓
      배송 취소 → 결제 환불 → 재고 복구 → 주문 취소
```

**필요한 기능:**
- 메시지 순서 보장
- 재시도 로직
- Dead Letter Queue
- 보상 트랜잭션
- 상태 추적

**결론: 직접 AMQP 필수** ✅

### 2. 이벤트 소싱 + CQRS ⭐⭐⭐⭐⭐
```
Command (Write) → EventStore → Event Bus → Query (Read)
```

**필요한 기능:**
- 이벤트 순서 보장
- 이벤트 재생 (Event Replay)
- 영속성 보장
- 메시지 손실 방지

**결론: 직접 AMQP 필수** ✅

### 3. 비동기 작업 처리 ⭐⭐⭐⭐
```
이미지 업로드 → 리사이징 큐 → 최적화 큐 → CDN 업로드
    (즉시)        (높은 우선순위)    (낮은 우선순위)
```

**필요한 기능:**
- 우선순위 큐
- 작업 재시도
- 타임아웃 설정
- Dead Letter Queue

**결론: 직접 AMQP 권장** ✅

### 4. 거래 추적 및 컴플라이언스 ⭐⭐⭐⭐⭐
```
모든 거래 이벤트 → 로깅 → 감사 로그 → 장기 보관
```

**필요한 기능:**
- 메시지 영속성 보장
- 메시지 손실 방지
- 순서 보장
- 메시지 확인(ACK) 제어

**결론: 직접 AMQP 필수** ✅

### 5. 사기 탐지 시스템 ⭐⭐⭐⭐
```
거래 이벤트 → 패턴 분석 큐 → AI 분석 → 알림
    (대용량)      (높은 처리량)
```

**필요한 기능:**
- 높은 처리량
- Prefetch 설정
- 배치 처리
- 성능 최적화

**결론: 직접 AMQP 권장** ✅

---

## 📈 하이브리드 접근 방식

### 전략: 단계적 도입

#### Phase 1: 직접 AMQP로 시작 (권장)
```typescript
// 핵심 기능은 처음부터 amqplib 사용
- Saga 패턴 트랜잭션
- 이벤트 소싱
- 거래 이벤트 처리
```

#### Phase 2: 간단한 작업은 NestJS (선택)
```typescript
// 복잡하지 않은 이벤트만 NestJS Microservices
- 간단한 알림 발송
- 로깅 이벤트
- 비중요 이벤트
```

### 혼합 사용 예제

```typescript
// 핵심: amqplib
@Injectable()
export class OrderSagaService {
  constructor(
    @Inject('RABBITMQ_CONNECTION')
    private connection: Connection,
  ) {}

  async executeOrderSaga(order: Order) {
    const channel = await this.connection.createChannel();

    // Saga 패턴 구현
    await channel.publish('orders', 'order.saga.start',
      Buffer.from(JSON.stringify(order)), {
        persistent: true,
        priority: 10
      }
    );
  }
}

// 간단한 작업: NestJS Microservices
@Controller()
export class NotificationsController {
  @EventPattern('user.registered')
  sendWelcomeEmail(@Payload() user: User) {
    // 간단한 이메일 발송
    this.emailService.sendWelcome(user.email);
  }
}
```

---

## 🚀 최종 권장사항

### ✅ 직접 AMQP 라이브러리 사용 강력 권장

**이유:**
1. **프로젝트 요구사항 충족**: Saga 패턴, 이벤트 소싱, 거래 무결성
2. **장기적 이득**: 초기 투자 시간은 증가하지만, 유지보수와 확장성에서 유리
3. **프로덕션 안정성**: 메시지 손실 방지, 재연결, Dead Letter Queue 완벽 제어
4. **성능**: 대용량 이벤트 처리 및 최적화 가능

### 📦 권장 패키지

```bash
# 핵심 라이브러리
pnpm add amqplib amqp-connection-manager

# 타입 정의
pnpm add -D @types/amqplib

# NestJS Microservices 제거 (선택)
# pnpm remove @nestjs/microservices
```

### 🎯 구현 단계

1. **Week 3**: AMQP 기본 연결 및 채널 관리
2. **Week 3**: Exchange, Queue, Binding 설정
3. **Week 3**: Producer/Consumer 패턴 구현
4. **Week 4**: Dead Letter Queue 및 재시도 로직
5. **Week 9**: Saga 패턴 구현 (주문/결제 워크플로우)

---

## 📚 다음 단계

상세 구현 가이드는 다음 문서 참조:
- **[6. AMQP_직접_구현_가이드.md](6. AMQP_직접_구현_가이드.md)** (작성 예정)

---

**문서 버전**: v1.0
**최종 업데이트**: 2025-10-15
**작성자**: 개발팀
