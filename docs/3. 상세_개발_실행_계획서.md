# 상세 개발 실행 계획서: 중고거래사이트 백엔드 API

## 📋 문서 정보

- **프로젝트**: 중고거래사이트 백엔드 API
- **버전**: v1.0
- **작성일**: 2025-10-15
- **개발 기간**: 16주 (4개월)
- **개발 방식**: 보일러플레이트 코드 구축 → 순차적 비즈니스 로직 구현

## 🎯 개발 전략 개요

### 핵심 전략
1. **보일러플레이트 우선**: 인프라, 공통 모듈, 설정 코드를 먼저 완성
2. **순차적 구현**: 각 도메인별 비즈니스 로직을 순서대로 구현
3. **테스트 주도**: 각 단계마다 테스트 코드 작성 및 검증
4. **점진적 통합**: 완성된 모듈부터 통합 테스트 진행

### 개발 우선순위
```
Phase 1: 보일러플레이트 (인프라 + 공통 모듈)
  ↓
Phase 2: 핵심 비즈니스 로직 (인증 → 상품 → 주문)
  ↓
Phase 3: 고급 기능 (검색, 채팅, 알림)
  ↓
Phase 4: 최적화 및 배포
```

---

## 🏗️ Phase 1: 보일러플레이트 구축 (1-4주)

### Week 1: 프로젝트 초기 설정 및 인프라 구성

#### Day 1-2: 패키지 설치 및 Docker 환경 구성

**목표**: 개발 환경 완전 구축

**작업 순서**:
1. **의존성 패키지 설치**
   ```bash
   # 데이터베이스 ORM 및 드라이버
   pnpm add @nestjs/typeorm typeorm pg
   pnpm add @nestjs/mongoose mongoose
   pnpm add @nestjs/redis redis
   pnpm add @prisma/client
   pnpm add -D prisma

   # 이벤트 아키텍처 (AMQP 직접 사용)
   pnpm add amqplib amqp-connection-manager
   pnpm add @nestjs/event-emitter @nestjs/cqrs
   pnpm add -D @types/amqplib
   # 참고: @nestjs/microservices는 사용하지 않음

   # 인증/보안
   pnpm add @nestjs/config
   pnpm add @nestjs/jwt @nestjs/passport passport-jwt
   pnpm add @nestjs/throttler helmet bcrypt
   pnpm add class-validator class-transformer
   pnpm add -D @types/bcrypt @types/passport-jwt

   # 파일 업로드
   pnpm add @nestjs/platform-express multer
   pnpm add @aws-sdk/client-s3
   pnpm add -D @types/multer

   # 유틸리티
   pnpm add @nestjs/axios axios
   pnpm add @nestjs/swagger swagger-ui-express
   pnpm add compression
   pnpm add -D @types/compression

   # 로깅 (Winston)
   pnpm add winston nest-winston winston-daily-rotate-file
   pnpm add -D @types/node
   ```

2. **Docker Compose 파일 작성**
   ```yaml
   # docker-compose.yml
   version: '3.8'

   services:
     # PostgreSQL (주 데이터베이스)
     postgres:
       image: postgres:14-alpine
       container_name: secondhand-postgres
       environment:
         POSTGRES_DB: secondhand_db
         POSTGRES_USER: postgres
         POSTGRES_PASSWORD: postgres123
       ports:
         - "5432:5432"
       volumes:
         - postgres_data:/var/lib/postgresql/data
       networks:
         - secondhand-network

     # MongoDB (비구조화 데이터)
     mongodb:
       image: mongo:6-alpine
       container_name: secondhand-mongodb
       environment:
         MONGO_INITDB_ROOT_USERNAME: mongo
         MONGO_INITDB_ROOT_PASSWORD: mongo123
       ports:
         - "27017:27017"
       volumes:
         - mongodb_data:/data/db
       networks:
         - secondhand-network

     # Redis (캐싱 및 세션)
     redis:
       image: redis:7-alpine
       container_name: secondhand-redis
       command: redis-server --requirepass redis123
       ports:
         - "6379:6379"
       volumes:
         - redis_data:/data
       networks:
         - secondhand-network

     # RabbitMQ (메시지 큐)
     rabbitmq:
       image: rabbitmq:3.12-management-alpine
       container_name: secondhand-rabbitmq
       environment:
         RABBITMQ_DEFAULT_USER: rabbit
         RABBITMQ_DEFAULT_PASS: rabbit123
       ports:
         - "5672:5672"   # AMQP
         - "15672:15672" # Management UI
       volumes:
         - rabbitmq_data:/var/lib/rabbitmq
       networks:
         - secondhand-network

     # Elasticsearch (검색 엔진)
     elasticsearch:
       image: docker.elastic.co/elasticsearch/elasticsearch:8.11.0
       container_name: secondhand-elasticsearch
       environment:
         - discovery.type=single-node
         - ES_JAVA_OPTS=-Xms512m -Xmx512m
         - xpack.security.enabled=false
       ports:
         - "9200:9200"
       volumes:
         - elasticsearch_data:/usr/share/elasticsearch/data
       networks:
         - secondhand-network

   networks:
     secondhand-network:
       driver: bridge

   volumes:
     postgres_data:
     mongodb_data:
     redis_data:
     rabbitmq_data:
     elasticsearch_data:
   ```

3. **환경 변수 설정**
   ```bash
   # .env
   # 애플리케이션
   NODE_ENV=development
   PORT=3000
   API_PREFIX=/api/v1

   # PostgreSQL
   DATABASE_HOST=localhost
   DATABASE_PORT=5432
   DATABASE_USERNAME=postgres
   DATABASE_PASSWORD=postgres123
   DATABASE_NAME=secondhand_db

   # MongoDB
   MONGODB_URI=mongodb://mongo:mongo123@localhost:27017/secondhand_db?authSource=admin

   # Redis
   REDIS_HOST=localhost
   REDIS_PORT=6379
   REDIS_PASSWORD=redis123

   # RabbitMQ
   RABBITMQ_URL=amqp://rabbit:rabbit123@localhost:5672

   # Elasticsearch
   ELASTICSEARCH_NODE=http://localhost:9200

   # JWT
   JWT_SECRET=your-super-secret-jwt-key-change-in-production
   JWT_EXPIRATION=1h
   JWT_REFRESH_SECRET=your-refresh-secret-key
   JWT_REFRESH_EXPIRATION=7d

   # 파일 업로드
   AWS_S3_REGION=ap-northeast-2
   AWS_S3_BUCKET_NAME=secondhand-uploads
   AWS_ACCESS_KEY_ID=your-aws-access-key
   AWS_SECRET_ACCESS_KEY=your-aws-secret-key

   # 외부 API (나중에 설정)
   TOSS_PAYMENTS_SECRET_KEY=
   KAKAO_REST_API_KEY=
   GOOGLE_CLIENT_ID=
   ```

4. **Dockerfile 작성**
   ```dockerfile
   # Dockerfile
   FROM node:20-alpine AS builder

   WORKDIR /app

   # 의존성 설치
   COPY package.json pnpm-lock.yaml ./
   RUN npm install -g pnpm && pnpm install --frozen-lockfile

   # 소스 복사 및 빌드
   COPY . .
   RUN pnpm run build

   # 프로덕션 이미지
   FROM node:20-alpine

   WORKDIR /app

   COPY --from=builder /app/dist ./dist
   COPY --from=builder /app/node_modules ./node_modules
   COPY package.json ./

   EXPOSE 3000

   CMD ["node", "dist/main"]
   ```

**검증 항목**:
- [ ] Docker Compose 실행 확인: `docker-compose up -d`
- [ ] 모든 컨테이너 정상 동작 확인
- [ ] 각 데이터베이스 연결 테스트
- [ ] RabbitMQ Management UI 접속 확인 (http://localhost:15672)

---

#### Day 3-5: 프로젝트 폴더 구조 및 공통 모듈 생성

**목표**: 표준화된 프로젝트 구조 및 공통 모듈 보일러플레이트 완성

**작업 순서**:

1. **프로젝트 폴더 구조 생성**
   ```bash
   # 공통 모듈
   nest g module common
   nest g module common/guards
   nest g module common/interceptors
   nest g module common/decorators
   nest g module common/pipes
   nest g module common/filters

   # 설정 모듈
   nest g module config

   # 데이터베이스 모듈
   nest g module database
   nest g module database/postgresql
   nest g module database/mongodb
   nest g module database/redis

   # 이벤트 시스템
   nest g module events

   # 큐 시스템
   nest g module queues

   # 보안 모듈
   nest g module security

   # 외부 연동 (나중에 구현)
   nest g module integrations

   # 도메인 모듈 (비즈니스 로직)
   nest g module modules/users
   nest g module modules/auth
   nest g module modules/products
   nest g module modules/orders
   nest g module modules/categories
   ```

2. **공통 설정 파일 작성**

   **a. 데이터베이스 설정 모듈**
   ```typescript
   // src/config/database.config.ts
   import { registerAs } from '@nestjs/config';

   export default registerAs('database', () => ({
     postgresql: {
       host: process.env.DATABASE_HOST || 'localhost',
       port: parseInt(process.env.DATABASE_PORT, 10) || 5432,
       username: process.env.DATABASE_USERNAME || 'postgres',
       password: process.env.DATABASE_PASSWORD || 'postgres123',
       database: process.env.DATABASE_NAME || 'secondhand_db',
     },
     mongodb: {
       uri: process.env.MONGODB_URI || 'mongodb://mongo:mongo123@localhost:27017/secondhand_db?authSource=admin',
     },
     redis: {
       host: process.env.REDIS_HOST || 'localhost',
       port: parseInt(process.env.REDIS_PORT, 10) || 6379,
       password: process.env.REDIS_PASSWORD || 'redis123',
     },
   }));
   ```

   **b. JWT 설정 모듈**
   ```typescript
   // src/config/jwt.config.ts
   import { registerAs } from '@nestjs/config';

   export default registerAs('jwt', () => ({
     secret: process.env.JWT_SECRET || 'your-secret-key',
     expiresIn: process.env.JWT_EXPIRATION || '1h',
     refreshSecret: process.env.JWT_REFRESH_SECRET || 'your-refresh-secret',
     refreshExpiresIn: process.env.JWT_REFRESH_EXPIRATION || '7d',
   }));
   ```

   **c. 애플리케이션 설정 모듈**
   ```typescript
   // src/config/app.config.ts
   import { registerAs } from '@nestjs/config';

   export default registerAs('app', () => ({
     nodeEnv: process.env.NODE_ENV || 'development',
     port: parseInt(process.env.PORT, 10) || 3000,
     apiPrefix: process.env.API_PREFIX || '/api/v1',
     corsOrigins: process.env.CORS_ORIGINS?.split(',') || ['http://localhost:3000'],
   }));
   ```

3. **공통 인터셉터 작성**

   **a. 응답 변환 인터셉터**
   ```typescript
   // src/common/interceptors/transform.interceptor.ts
   import {
     Injectable,
     NestInterceptor,
     ExecutionContext,
     CallHandler,
   } from '@nestjs/common';
   import { Observable } from 'rxjs';
   import { map } from 'rxjs/operators';

   export interface Response<T> {
     success: boolean;
     statusCode: number;
     message: string;
     data: T;
     timestamp: string;
   }

   @Injectable()
   export class TransformInterceptor<T>
     implements NestInterceptor<T, Response<T>>
   {
     intercept(
       context: ExecutionContext,
       next: CallHandler,
     ): Observable<Response<T>> {
       return next.handle().pipe(
         map((data) => ({
           success: true,
           statusCode: context.switchToHttp().getResponse().statusCode,
           message: 'Request successful',
           data,
           timestamp: new Date().toISOString(),
         })),
       );
     }
   }
   ```

   **b. 로깅 인터셉터**
   ```typescript
   // src/common/interceptors/logging.interceptor.ts
   import {
     Injectable,
     NestInterceptor,
     ExecutionContext,
     CallHandler,
     Logger,
   } from '@nestjs/common';
   import { Observable } from 'rxjs';
   import { tap } from 'rxjs/operators';

   @Injectable()
   export class LoggingInterceptor implements NestInterceptor {
     private readonly logger = new Logger(LoggingInterceptor.name);

     intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
       const request = context.switchToHttp().getRequest();
       const method = request.method;
       const url = request.url;
       const now = Date.now();

       return next.handle().pipe(
         tap(() => {
           const response = context.switchToHttp().getResponse();
           const statusCode = response.statusCode;
           const delay = Date.now() - now;

           this.logger.log(
             `${method} ${url} ${statusCode} - ${delay}ms`,
           );
         }),
       );
     }
   }
   ```

4. **공통 필터 작성**

   **예외 필터**
   ```typescript
   // src/common/filters/http-exception.filter.ts
   import {
     ExceptionFilter,
     Catch,
     ArgumentsHost,
     HttpException,
     HttpStatus,
     Logger,
   } from '@nestjs/common';
   import { Request, Response } from 'express';

   @Catch()
   export class AllExceptionsFilter implements ExceptionFilter {
     private readonly logger = new Logger(AllExceptionsFilter.name);

     catch(exception: unknown, host: ArgumentsHost) {
       const ctx = host.switchToHttp();
       const response = ctx.getResponse<Response>();
       const request = ctx.getRequest<Request>();

       const status =
         exception instanceof HttpException
           ? exception.getStatus()
           : HttpStatus.INTERNAL_SERVER_ERROR;

       const message =
         exception instanceof HttpException
           ? exception.getResponse()
           : 'Internal server error';

       this.logger.error(
         `HTTP Status: ${status} Error Message: ${JSON.stringify(message)}`,
         exception instanceof Error ? exception.stack : '',
       );

       response.status(status).json({
         success: false,
         statusCode: status,
         timestamp: new Date().toISOString(),
         path: request.url,
         message: typeof message === 'string' ? message : (message as any).message,
       });
     }
   }
   ```

5. **공통 파이프 작성**

   **검증 파이프 설정**
   ```typescript
   // src/common/pipes/validation.pipe.ts
   import { ValidationPipe } from '@nestjs/common';

   export const validationPipeConfig = new ValidationPipe({
     whitelist: true, // DTO에 없는 속성 제거
     forbidNonWhitelisted: true, // DTO에 없는 속성 있으면 에러
     transform: true, // 타입 자동 변환
     transformOptions: {
       enableImplicitConversion: true,
     },
   });
   ```

6. **공통 데코레이터 작성**

   **사용자 정보 데코레이터**
   ```typescript
   // src/common/decorators/user.decorator.ts
   import { createParamDecorator, ExecutionContext } from '@nestjs/common';

   export const CurrentUser = createParamDecorator(
     (data: string, ctx: ExecutionContext) => {
       const request = ctx.switchToHttp().getRequest();
       const user = request.user;

       return data ? user?.[data] : user;
     },
   );
   ```

   **공개 API 데코레이터**
   ```typescript
   // src/common/decorators/public.decorator.ts
   import { SetMetadata } from '@nestjs/common';

   export const IS_PUBLIC_KEY = 'isPublic';
   export const Public = () => SetMetadata(IS_PUBLIC_KEY, true);
   ```

**검증 항목**:
- [ ] 폴더 구조 생성 완료
- [ ] 공통 모듈 파일 생성 완료
- [ ] 설정 파일 작성 및 환경 변수 로드 확인
- [ ] 인터셉터, 필터, 파이프 작성 완료

---

### Week 2: 데이터베이스 연결 및 ORM 설정

#### Day 6-8: Prisma 및 TypeORM 설정

**목표**: PostgreSQL Prisma ORM 설정 완료

**작업 순서**:

1. **Prisma 초기화 및 스키마 작성**
   ```bash
   # Prisma 초기화
   npx prisma init
   ```

2. **Prisma 스키마 작성 (기본 엔티티)**
   ```prisma
   // prisma/schema.prisma
   generator client {
     provider = "prisma-client-js"
   }

   datasource db {
     provider = "postgresql"
     url      = env("DATABASE_URL")
   }

   // 사용자 테이블
   model User {
     id              Int       @id @default(autoincrement())
     email           String    @unique @db.VarChar(255)
     passwordHash    String    @map("password_hash") @db.VarChar(255)
     phone           String?   @db.VarChar(20)
     emailVerified   Boolean   @default(false) @map("email_verified")
     phoneVerified   Boolean   @default(false) @map("phone_verified")
     status          UserStatus @default(ACTIVE)
     createdAt       DateTime  @default(now()) @map("created_at")
     updatedAt       DateTime  @updatedAt @map("updated_at")

     // 관계
     userRoles       UserRole[]
     products        Product[]
     ordersAsBuyer   Order[]   @relation("BuyerOrders")
     ordersAsSeller  Order[]   @relation("SellerOrders")
     reviews         Review[]

     @@map("users")
   }

   enum UserStatus {
     ACTIVE
     INACTIVE
     SUSPENDED
     DELETED
   }

   // 역할 테이블
   model Role {
     id          Int       @id @default(autoincrement())
     name        String    @unique @db.VarChar(50)
     description String?   @db.Text
     createdAt   DateTime  @default(now()) @map("created_at")

     // 관계
     userRoles   UserRole[]

     @@map("roles")
   }

   // 사용자-역할 중간 테이블
   model UserRole {
     userId    Int
     roleId    Int
     createdAt DateTime @default(now()) @map("created_at")

     user User @relation(fields: [userId], references: [id], onDelete: Cascade)
     role Role @relation(fields: [roleId], references: [id], onDelete: Cascade)

     @@id([userId, roleId])
     @@map("user_roles")
   }

   // 카테고리 테이블 (계층 구조)
   model Category {
     id        Int       @id @default(autoincrement())
     name      String    @db.VarChar(100)
     parentId  Int?      @map("parent_id")
     level     Int
     path      String?   @db.VarChar(500)
     createdAt DateTime  @default(now()) @map("created_at")
     updatedAt DateTime  @updatedAt @map("updated_at")

     // 관계
     parent    Category?  @relation("CategoryHierarchy", fields: [parentId], references: [id])
     children  Category[] @relation("CategoryHierarchy")
     products  Product[]

     @@map("categories")
   }

   // 상품 테이블 (기본 정보만)
   model Product {
     id            Int           @id @default(autoincrement())
     sellerId      Int           @map("seller_id")
     categoryId    Int           @map("category_id")
     title         String        @db.VarChar(255)
     price         Decimal       @db.Decimal(10, 2)
     status        ProductStatus @default(ACTIVE)
     stockQuantity Int           @default(1) @map("stock_quantity")
     viewCount     Int           @default(0) @map("view_count")
     likeCount     Int           @default(0) @map("like_count")
     createdAt     DateTime      @default(now()) @map("created_at")
     updatedAt     DateTime      @updatedAt @map("updated_at")

     // 관계
     seller     User        @relation(fields: [sellerId], references: [id])
     category   Category    @relation(fields: [categoryId], references: [id])
     orderItems OrderItem[]

     @@index([sellerId])
     @@index([categoryId])
     @@index([status])
     @@map("products")
   }

   enum ProductStatus {
     ACTIVE
     RESERVED
     SOLD_OUT
     DELETED
   }

   // 주문 테이블
   model Order {
     id          Int         @id @default(autoincrement())
     buyerId     Int         @map("buyer_id")
     sellerId    Int         @map("seller_id")
     totalAmount Decimal     @map("total_amount") @db.Decimal(10, 2)
     status      OrderStatus @default(PENDING)
     createdAt   DateTime    @default(now()) @map("created_at")
     updatedAt   DateTime    @updatedAt @map("updated_at")

     // 관계
     buyer      User        @relation("BuyerOrders", fields: [buyerId], references: [id])
     seller     User        @relation("SellerOrders", fields: [sellerId], references: [id])
     orderItems OrderItem[]
     payment    Payment?

     @@index([buyerId])
     @@index([sellerId])
     @@index([status])
     @@map("orders")
   }

   enum OrderStatus {
     PENDING
     PAID
     PROCESSING
     SHIPPED
     DELIVERED
     CANCELLED
     REFUNDED
   }

   // 주문 아이템 테이블
   model OrderItem {
     id        Int     @id @default(autoincrement())
     orderId   Int     @map("order_id")
     productId Int     @map("product_id")
     quantity  Int
     unitPrice Decimal @map("unit_price") @db.Decimal(10, 2)

     // 관계
     order   Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
     product Product @relation(fields: [productId], references: [id])

     @@index([orderId])
     @@index([productId])
     @@map("order_items")
   }

   // 결제 테이블
   model Payment {
     id            Int           @id @default(autoincrement())
     orderId       Int           @unique @map("order_id")
     paymentMethod String        @map("payment_method") @db.VarChar(50)
     amount        Decimal       @db.Decimal(10, 2)
     status        PaymentStatus @default(PENDING)
     transactionId String?       @map("transaction_id") @db.VarChar(255)
     paidAt        DateTime?     @map("paid_at")
     createdAt     DateTime      @default(now()) @map("created_at")

     // 관계
     order Order @relation(fields: [orderId], references: [id])

     @@index([orderId])
     @@index([transactionId])
     @@map("payments")
   }

   enum PaymentStatus {
     PENDING
     PAID
     FAILED
     CANCELLED
     REFUNDED
   }

   // 리뷰 테이블
   model Review {
     id         Int      @id @default(autoincrement())
     reviewerId Int      @map("reviewer_id")
     revieweeId Int      @map("reviewee_id")
     orderId    Int      @map("order_id")
     rating     Int      @db.SmallInt
     comment    String?  @db.Text
     createdAt  DateTime @default(now()) @map("created_at")

     // 관계
     reviewer User @relation(fields: [reviewerId], references: [id])

     @@index([reviewerId])
     @@index([revieweeId])
     @@map("reviews")
   }
   ```

3. **Prisma 마이그레이션 실행**
   ```bash
   # DATABASE_URL 설정
   echo "DATABASE_URL=postgresql://postgres:postgres123@localhost:5432/secondhand_db" >> .env

   # 마이그레이션 생성 및 실행
   npx prisma migrate dev --name init

   # Prisma Client 생성
   npx prisma generate
   ```

4. **Prisma 모듈 생성**
   ```typescript
   // src/prisma/prisma.module.ts
   import { Module, Global } from '@nestjs/common';
   import { PrismaService } from './prisma.service';

   @Global()
   @Module({
     providers: [PrismaService],
     exports: [PrismaService],
   })
   export class PrismaModule {}
   ```

   ```typescript
   // src/prisma/prisma.service.ts
   import { Injectable, OnModuleInit, OnModuleDestroy, Logger } from '@nestjs/common';
   import { PrismaClient } from '@prisma/client';

   @Injectable()
   export class PrismaService extends PrismaClient implements OnModuleInit, OnModuleDestroy {
     private readonly logger = new Logger(PrismaService.name);

     async onModuleInit() {
       await this.$connect();
       this.logger.log('PostgreSQL database connected');
     }

     async onModuleDestroy() {
       await this.$disconnect();
       this.logger.log('PostgreSQL database disconnected');
     }
   }
   ```

**검증 항목**:
- [ ] Prisma 스키마 작성 완료
- [ ] 마이그레이션 실행 성공
- [ ] Prisma Client 생성 확인
- [ ] PrismaService 모듈 생성 및 테스트

---

#### Day 9-10: MongoDB 및 Redis 연결 설정

**목표**: MongoDB, Redis 연결 및 모듈 설정 완료

**작업 순서**:

1. **MongoDB 스키마 정의**
   ```typescript
   // src/database/mongodb/schemas/product-detail.schema.ts
   import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
   import { Document } from 'mongoose';

   @Schema({ collection: 'product_details', timestamps: true })
   export class ProductDetail extends Document {
     @Prop({ required: true, unique: true })
     productId: number;

     @Prop({ required: true })
     description: string;

     @Prop({ type: [{ url: String, alt: String, order: Number }] })
     images: { url: string; alt: string; order: number }[];

     @Prop({
       type: {
         brand: String,
         condition: String,
         location: {
           city: String,
           district: String,
           coordinates: [Number],
         },
       },
     })
     specifications: {
       brand?: string;
       condition?: string;
       location?: {
         city: string;
         district: string;
         coordinates: [number, number];
       };
     };

     @Prop({ type: { views: Number, likes: Number, tags: [String] }, default: {} })
     metadata: {
       views: number;
       likes: number;
       tags: string[];
     };
   }

   export const ProductDetailSchema = SchemaFactory.createForClass(ProductDetail);
   ```

   ```typescript
   // src/database/mongodb/schemas/message.schema.ts
   import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
   import { Document } from 'mongoose';

   @Schema({ collection: 'messages', timestamps: true })
   export class Message extends Document {
     @Prop({ required: true })
     conversationId: string;

     @Prop({ required: true })
     senderId: number;

     @Prop({ required: true })
     receiverId: number;

     @Prop({ required: true })
     message: string;

     @Prop({ enum: ['text', 'image', 'system'], default: 'text' })
     messageType: string;

     @Prop()
     readAt?: Date;
   }

   export const MessageSchema = SchemaFactory.createForClass(Message);
   ```

2. **MongoDB 모듈 설정**
   ```typescript
   // src/database/mongodb/mongodb.module.ts
   import { Module } from '@nestjs/common';
   import { MongooseModule } from '@nestjs/mongoose';
   import { ConfigService } from '@nestjs/config';

   @Module({
     imports: [
       MongooseModule.forRootAsync({
         inject: [ConfigService],
         useFactory: (configService: ConfigService) => ({
           uri: configService.get<string>('database.mongodb.uri'),
         }),
       }),
     ],
   })
   export class MongodbModule {}
   ```

3. **Redis 모듈 설정**
   ```typescript
   // src/database/redis/redis.module.ts
   import { Module } from '@nestjs/common';
   import { RedisModule as NestRedisModule } from '@nestjs/redis';
   import { ConfigService } from '@nestjs/config';

   @Module({
     imports: [
       NestRedisModule.forRootAsync({
         inject: [ConfigService],
         useFactory: (configService: ConfigService) => ({
           config: {
             host: configService.get<string>('database.redis.host'),
             port: configService.get<number>('database.redis.port'),
             password: configService.get<string>('database.redis.password'),
           },
         }),
       }),
     ],
   })
   export class RedisConfigModule {}
   ```

**검증 항목**:
- [ ] MongoDB 스키마 정의 완료
- [ ] MongoDB 연결 테스트
- [ ] Redis 연결 테스트
- [ ] 각 데이터베이스 모듈 app.module에 등록

---

### Week 3: 이벤트 시스템 및 공통 유틸리티

#### Day 11-13: RabbitMQ 이벤트 시스템 구축 (AMQP 직접 사용)

**목표**: amqplib를 사용한 프로덕션급 이벤트 시스템 구축

> **참고**: 상세 내용은 다음 문서 참조
> - [5. RabbitMQ_구현_방식_비교_분석.md](5. RabbitMQ_구현_방식_비교_분석.md)
> - [6. AMQP_직접_구현_가이드.md](6. AMQP_직접_구현_가이드.md)

**작업 순서**:

1. **RabbitMQ 연결 관리 서비스**
   ```typescript
   // src/rabbitmq/rabbitmq-connection.service.ts
   import { Injectable, OnModuleInit, OnModuleDestroy, Logger } from '@nestjs/common';
   import { ConfigService } from '@nestjs/config';
   import * as amqp from 'amqp-connection-manager';
   import { ChannelWrapper } from 'amqp-connection-manager';
   import { ConfirmChannel } from 'amqplib';

   @Injectable()
   export class RabbitMQConnectionService implements OnModuleInit, OnModuleDestroy {
     private readonly logger = new Logger(RabbitMQConnectionService.name);
     private connection: amqp.AmqpConnectionManager;
     private channelWrapper: ChannelWrapper;

     constructor(private configService: ConfigService) {}

     async onModuleInit() {
       await this.connect();
     }

     async onModuleDestroy() {
       await this.disconnect();
     }

     private async connect(): Promise<void> {
       const url = this.configService.get<string>('RABBITMQ_URL') || 'amqp://localhost';

       this.logger.log(`RabbitMQ 연결 시작: ${url}`);

       // 자동 재연결 지원
       this.connection = amqp.connect([url], {
         heartbeatIntervalInSeconds: 30,
         reconnectTimeInSeconds: 1,
       });

       // 연결 이벤트
       this.connection.on('connect', () => {
         this.logger.log('✅ RabbitMQ 연결 성공');
       });

       this.connection.on('disconnect', (err) => {
         this.logger.error('❌ RabbitMQ 연결 끊김', err.err);
       });

       // 채널 생성
       this.channelWrapper = this.connection.createChannel({
         json: false,
         setup: async (channel: ConfirmChannel) => {
           await this.setupInfrastructure(channel);
         },
       });

       await this.channelWrapper.waitForConnect();
       this.logger.log('✅ RabbitMQ 초기화 완료');
     }

     private async setupInfrastructure(channel: ConfirmChannel): Promise<void> {
       // Exchange 설정
       await channel.assertExchange('events', 'topic', { durable: true });
       await channel.assertExchange('commands', 'direct', { durable: true });
       await channel.assertExchange('events-dlx', 'topic', { durable: true });

       // 주문 큐 설정
       await channel.assertQueue('orders-queue', {
         durable: true,
         deadLetterExchange: 'events-dlx',
         deadLetterRoutingKey: 'orders.failed',
       });
       await channel.bindQueue('orders-queue', 'events', 'order.*');

       // 주문 DLQ
       await channel.assertQueue('orders-dlq', { durable: true });
       await channel.bindQueue('orders-dlq', 'events-dlx', 'orders.failed');

       // 결제 큐 설정
       await channel.assertQueue('payments-queue', {
         durable: true,
         deadLetterExchange: 'events-dlx',
         deadLetterRoutingKey: 'payments.failed',
       });
       await channel.bindQueue('payments-queue', 'events', 'payment.*');

       // 알림 큐 (우선순위)
       await channel.assertQueue('notifications-queue', {
         durable: true,
         maxPriority: 10,
       });
       await channel.bindQueue('notifications-queue', 'events', 'notification.*');

       this.logger.log('✅ RabbitMQ 인프라 설정 완료');
     }

     private async disconnect(): Promise<void> {
       if (this.channelWrapper) {
         await this.channelWrapper.close();
       }
       if (this.connection) {
         await this.connection.close();
       }
       this.logger.log('✅ RabbitMQ 연결 종료');
     }

     getChannelWrapper(): ChannelWrapper {
       return this.channelWrapper;
     }

     isConnected(): boolean {
       return this.connection?.isConnected() || false;
     }
   }
   ```

2. **이벤트 타입 정의**
   ```typescript
   // src/events/types/event.types.ts
   export enum EventType {
     USER_REGISTERED = 'user.registered',
     USER_VERIFIED = 'user.verified',
     PRODUCT_CREATED = 'product.created',
     PRODUCT_UPDATED = 'product.updated',
     ORDER_CREATED = 'order.created',
     ORDER_PAID = 'order.paid',
     PAYMENT_COMPLETED = 'payment.completed',
   }

   export interface BaseEvent {
     eventId: string;
     eventType: EventType;
     timestamp: Date;
     userId?: number;
   }

   export interface UserRegisteredEvent extends BaseEvent {
     eventType: EventType.USER_REGISTERED;
     data: {
       userId: number;
       email: string;
     };
   }

   export interface ProductCreatedEvent extends BaseEvent {
     eventType: EventType.PRODUCT_CREATED;
     data: {
       productId: number;
       sellerId: number;
       title: string;
       price: number;
     };
   }

   export interface OrderCreatedEvent extends BaseEvent {
     eventType: EventType.ORDER_CREATED;
     data: {
       orderId: number;
       buyerId: number;
       sellerId: number;
       totalAmount: number;
     };
   }
   ```

3. **이벤트 발행자 서비스**
   ```typescript
   // src/events/publishers/event-publisher.service.ts
   import { Injectable, Inject, Logger } from '@nestjs/common';
   import { ClientProxy } from '@nestjs/microservices';
   import { EventEmitter2 } from '@nestjs/event-emitter';
   import { BaseEvent } from '../types/event.types';

   @Injectable()
   export class EventPublisherService {
     private readonly logger = new Logger(EventPublisherService.name);

     constructor(
       @Inject('RABBITMQ_SERVICE') private rabbitClient: ClientProxy,
       private eventEmitter: EventEmitter2,
     ) {}

     /**
      * 로컬 이벤트 발행 (같은 프로세스 내)
      */
     emitLocal<T extends BaseEvent>(event: T): void {
       this.logger.log(`Emitting local event: ${event.eventType}`);
       this.eventEmitter.emit(event.eventType, event);
     }

     /**
      * 분산 이벤트 발행 (RabbitMQ를 통한 다른 서비스로)
      */
     async emitDistributed<T extends BaseEvent>(event: T): Promise<void> {
       this.logger.log(`Emitting distributed event: ${event.eventType}`);
       await this.rabbitClient.emit(event.eventType, event).toPromise();
     }

     /**
      * 로컬 + 분산 동시 발행
      */
     async emitAll<T extends BaseEvent>(event: T): Promise<void> {
       this.emitLocal(event);
       await this.emitDistributed(event);
     }
   }
   ```

4. **이벤트 핸들러 베이스 클래스**
   ```typescript
   // src/events/handlers/base-event.handler.ts
   import { Logger } from '@nestjs/common';
   import { BaseEvent } from '../types/event.types';

   export abstract class BaseEventHandler<T extends BaseEvent> {
     protected readonly logger: Logger;

     constructor(handlerName: string) {
       this.logger = new Logger(handlerName);
     }

     abstract handle(event: T): Promise<void>;

     protected logEvent(event: T): void {
       this.logger.log(
         `Handling event: ${event.eventType} | EventId: ${event.eventId}`,
       );
     }
   }
   ```

2. **Producer 및 Consumer 서비스 구현**
   - Producer: 메시지 발행 서비스
   - Consumer: 메시지 소비 및 처리
   - Dead Letter Queue 처리 로직
   - 재시도 메커니즘

3. **RabbitMQ 모듈 통합**
   ```typescript
   // src/rabbitmq/rabbitmq.module.ts
   @Global()
   @Module({
     providers: [
       RabbitMQConnectionService,
       RabbitMQProducerService,
       RabbitMQConsumerService,
     ],
     exports: [
       RabbitMQConnectionService,
       RabbitMQProducerService,
       RabbitMQConsumerService,
     ],
   })
   export class RabbitMQModule {}
   ```

**검증 항목**:
- [ ] RabbitMQ 연결 및 자동 재연결 확인
- [ ] Exchange, Queue, Binding 생성 확인
- [ ] 메시지 발행/소비 테스트
- [ ] Dead Letter Queue 동작 확인
- [ ] 우선순위 큐 테스트
- [ ] RabbitMQ Management UI에서 모니터링

---

#### Day 14-15: Winston 로거 설정 및 공통 유틸리티

**목표**: Winston 로거 구축 및 재사용 가능한 유틸리티 함수 작성

**작업 순서**:

1. **Winston 로거 설정** ⭐ 우선순위 높음

   > **참고**: 상세 내용은 [docs/4. Winston_로거_구현_가이드.md](4. Winston_로거_구현_가이드.md) 참조

   ```typescript
   // src/config/logger.config.ts
   import { WinstonModuleOptions } from 'nest-winston';
   import * as winston from 'winston';
   import * as DailyRotateFile from 'winston-daily-rotate-file';
   import { utilities as nestWinstonModuleUtilities } from 'nest-winston';

   /**
    * 민감정보 마스킹 함수
    */
   const maskSensitiveData = winston.format((info) => {
     const message = JSON.stringify(info);

     info.message = message
       .replace(/"password":\s*"[^"]*"/g, '"password": "****"')
       .replace(/"passwordHash":\s*"[^"]*"/g, '"passwordHash": "****"')
       .replace(/\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}/g, '****-****-****-****')
       .replace(/([a-zA-Z0-9._-]+)@/g, '***@')
       .replace(/\d{3}[-\s]?\d{3,4}[-\s]?\d{4}/g, '***-****-****');

     return info;
   });

   /**
    * Winston 로거 설정
    */
   export const winstonConfig: WinstonModuleOptions = {
     transports: [
       // 콘솔 출력
       new winston.transports.Console({
         level: process.env.NODE_ENV === 'production' ? 'info' : 'debug',
         format: winston.format.combine(
           winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
           winston.format.ms(),
           nestWinstonModuleUtilities.format.nestLike('SecondhandAPI', {
             colors: true,
             prettyPrint: true,
           }),
         ),
       }),

       // 에러 로그 파일
       new DailyRotateFile({
         level: 'error',
         dirname: 'logs',
         filename: 'error-%DATE%.log',
         datePattern: 'YYYY-MM-DD',
         zippedArchive: true,
         maxSize: '20m',
         maxFiles: '14d',
         format: winston.format.combine(
           winston.format.timestamp(),
           maskSensitiveData(),
           winston.format.json(),
         ),
       }),

       // 전체 로그 파일
       new DailyRotateFile({
         level: 'info',
         dirname: 'logs',
         filename: 'combined-%DATE%.log',
         datePattern: 'YYYY-MM-DD',
         zippedArchive: true,
         maxSize: '20m',
         maxFiles: '14d',
         format: winston.format.combine(
           winston.format.timestamp(),
           maskSensitiveData(),
           winston.format.json(),
         ),
       }),

       // 거래 로그 파일 (별도 보관)
       new DailyRotateFile({
         level: 'info',
         dirname: 'logs/transactions',
         filename: 'transaction-%DATE%.log',
         datePattern: 'YYYY-MM-DD',
         zippedArchive: true,
         maxSize: '50m',
         maxFiles: '30d',
         format: winston.format.combine(
           winston.format.timestamp(),
           winston.format.json(),
         ),
       }),
     ],

     exceptionHandlers: [
       new DailyRotateFile({
         dirname: 'logs',
         filename: 'exceptions-%DATE%.log',
         datePattern: 'YYYY-MM-DD',
         maxSize: '20m',
         maxFiles: '14d',
       }),
     ],

     rejectionHandlers: [
       new DailyRotateFile({
         dirname: 'logs',
         filename: 'rejections-%DATE%.log',
         datePattern: 'YYYY-MM-DD',
         maxSize: '20m',
         maxFiles: '14d',
       }),
     ],
   };
   ```

   **AppModule에 Winston 통합**
   ```typescript
   // src/app.module.ts
   import { WinstonModule } from 'nest-winston';
   import { winstonConfig } from './config/logger.config';

   @Module({
     imports: [
       // ... 다른 모듈들
       WinstonModule.forRoot(winstonConfig),
     ],
   })
   export class AppModule {}
   ```

   **main.ts에서 Winston 적용**
   ```typescript
   // src/main.ts
   import { WINSTON_MODULE_NEST_PROVIDER } from 'nest-winston';

   async function bootstrap() {
     const app = await NestFactory.create(AppModule, {
       bufferLogs: true,
     });

     // Winston 로거를 애플리케이션 로거로 설정
     app.useLogger(app.get(WINSTON_MODULE_NEST_PROVIDER));

     // ... 나머지 설정
   }
   ```

   **로그 디렉토리 생성 및 .gitignore 설정**
   ```bash
   # 로그 디렉토리 생성
   mkdir -p logs/transactions

   # .gitignore에 추가
   echo "logs/" >> .gitignore
   ```

2. **날짜 유틸리티**
   ```typescript
   // src/shared/utils/date.util.ts
   import { format, addDays, subDays, startOfDay, endOfDay } from 'date-fns';

   export class DateUtil {
     static format(date: Date, pattern: string = 'yyyy-MM-dd HH:mm:ss'): string {
       return format(date, pattern);
     }

     static addDays(date: Date, days: number): Date {
       return addDays(date, days);
     }

     static subDays(date: Date, days: number): Date {
       return subDays(date, days);
     }

     static startOfDay(date: Date): Date {
       return startOfDay(date);
     }

     static endOfDay(date: Date): Date {
       return endOfDay(date);
     }
   }
   ```

2. **암호화 유틸리티**
   ```typescript
   // src/shared/utils/crypto.util.ts
   import * as bcrypt from 'bcrypt';
   import { createCipheriv, createDecipheriv, randomBytes } from 'crypto';

   export class CryptoUtil {
     private static readonly ALGORITHM = 'aes-256-gcm';
     private static readonly SALT_ROUNDS = 10;

     /**
      * 비밀번호 해싱
      */
     static async hashPassword(password: string): Promise<string> {
       return bcrypt.hash(password, this.SALT_ROUNDS);
     }

     /**
      * 비밀번호 검증
      */
     static async comparePassword(
       password: string,
       hash: string,
     ): Promise<boolean> {
       return bcrypt.compare(password, hash);
     }

     /**
      * AES-256 암호화
      */
     static encrypt(text: string, secretKey: string): string {
       const iv = randomBytes(16);
       const key = Buffer.from(secretKey, 'hex');
       const cipher = createCipheriv(this.ALGORITHM, key, iv);

       let encrypted = cipher.update(text, 'utf8', 'hex');
       encrypted += cipher.final('hex');
       const authTag = cipher.getAuthTag();

       return `${iv.toString('hex')}:${authTag.toString('hex')}:${encrypted}`;
     }

     /**
      * AES-256 복호화
      */
     static decrypt(encryptedData: string, secretKey: string): string {
       const [ivHex, authTagHex, encrypted] = encryptedData.split(':');
       const iv = Buffer.from(ivHex, 'hex');
       const authTag = Buffer.from(authTagHex, 'hex');
       const key = Buffer.from(secretKey, 'hex');

       const decipher = createDecipheriv(this.ALGORITHM, key, iv);
       decipher.setAuthTag(authTag);

       let decrypted = decipher.update(encrypted, 'hex', 'utf8');
       decrypted += decipher.final('utf8');

       return decrypted;
     }
   }
   ```

3. **페이지네이션 유틸리티**
   ```typescript
   // src/shared/utils/pagination.util.ts
   export interface PaginationOptions {
     page: number;
     limit: number;
   }

   export interface PaginatedResult<T> {
     data: T[];
     meta: {
       total: number;
       page: number;
       limit: number;
       totalPages: number;
       hasNextPage: boolean;
       hasPreviousPage: boolean;
     };
   }

   export class PaginationUtil {
     static paginate<T>(
       data: T[],
       total: number,
       options: PaginationOptions,
     ): PaginatedResult<T> {
       const { page, limit } = options;
       const totalPages = Math.ceil(total / limit);

       return {
         data,
         meta: {
           total,
           page,
           limit,
           totalPages,
           hasNextPage: page < totalPages,
           hasPreviousPage: page > 1,
         },
       };
     }

     static getSkip(page: number, limit: number): number {
       return (page - 1) * limit;
     }
   }
   ```

4. **공통 DTO 클래스**
   ```typescript
   // src/shared/dto/pagination.dto.ts
   import { IsOptional, IsInt, Min, Max } from 'class-validator';
   import { Type } from 'class-transformer';

   export class PaginationDto {
     @IsOptional()
     @Type(() => Number)
     @IsInt()
     @Min(1)
     page?: number = 1;

     @IsOptional()
     @Type(() => Number)
     @IsInt()
     @Min(1)
     @Max(100)
     limit?: number = 10;
   }
   ```

**검증 항목**:
- [ ] Winston 로거 설정 완료
- [ ] 로그 파일 생성 확인 (logs/ 디렉토리)
- [ ] 민감정보 마스킹 테스트
- [ ] 유틸리티 함수 작성 완료
- [ ] 단위 테스트 작성
- [ ] 공통 DTO 작성 완료

---

### Week 4: 보안 설정 및 미들웨어

#### Day 16-18: JWT 인증 가드 및 보안 미들웨어

**목표**: 인증/인가 보일러플레이트 완성

**작업 순서**:

1. **JWT Strategy 작성**
   ```typescript
   // src/common/guards/jwt-auth.guard.ts
   import { Injectable, ExecutionContext } from '@nestjs/common';
   import { AuthGuard } from '@nestjs/passport';
   import { Reflector } from '@nestjs/core';
   import { IS_PUBLIC_KEY } from '../decorators/public.decorator';

   @Injectable()
   export class JwtAuthGuard extends AuthGuard('jwt') {
     constructor(private reflector: Reflector) {
       super();
     }

     canActivate(context: ExecutionContext) {
       const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
         context.getHandler(),
         context.getClass(),
       ]);

       if (isPublic) {
         return true;
       }

       return super.canActivate(context);
     }
   }
   ```

   ```typescript
   // src/common/strategies/jwt.strategy.ts
   import { Injectable, UnauthorizedException } from '@nestjs/common';
   import { PassportStrategy } from '@nestjs/passport';
   import { ExtractJwt, Strategy } from 'passport-jwt';
   import { ConfigService } from '@nestjs/config';

   export interface JwtPayload {
     sub: number;
     email: string;
     roles: string[];
   }

   @Injectable()
   export class JwtStrategy extends PassportStrategy(Strategy) {
     constructor(private configService: ConfigService) {
       super({
         jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
         ignoreExpiration: false,
         secretOrKey: configService.get<string>('jwt.secret'),
       });
     }

     async validate(payload: JwtPayload) {
       if (!payload.sub || !payload.email) {
         throw new UnauthorizedException('Invalid token');
       }

       return {
         userId: payload.sub,
         email: payload.email,
         roles: payload.roles,
       };
     }
   }
   ```

2. **역할 기반 가드**
   ```typescript
   // src/common/guards/roles.guard.ts
   import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
   import { Reflector } from '@nestjs/core';

   export const ROLES_KEY = 'roles';

   @Injectable()
   export class RolesGuard implements CanActivate {
     constructor(private reflector: Reflector) {}

     canActivate(context: ExecutionContext): boolean {
       const requiredRoles = this.reflector.getAllAndOverride<string[]>(
         ROLES_KEY,
         [context.getHandler(), context.getClass()],
       );

       if (!requiredRoles) {
         return true;
       }

       const { user } = context.switchToHttp().getRequest();
       return requiredRoles.some((role) => user.roles?.includes(role));
     }
   }
   ```

   ```typescript
   // src/common/decorators/roles.decorator.ts
   import { SetMetadata } from '@nestjs/common';
   import { ROLES_KEY } from '../guards/roles.guard';

   export const Roles = (...roles: string[]) => SetMetadata(ROLES_KEY, roles);
   ```

3. **보안 미들웨어 설정**
   ```typescript
   // src/main.ts
   import { NestFactory } from '@nestjs/core';
   import { AppModule } from './app.module';
   import { ValidationPipe, Logger } from '@nestjs/common';
   import { ConfigService } from '@nestjs/config';
   import * as compression from 'compression';
   import helmet from 'helmet';
   import { AllExceptionsFilter } from './common/filters/http-exception.filter';
   import { TransformInterceptor } from './common/interceptors/transform.interceptor';
   import { LoggingInterceptor } from './common/interceptors/logging.interceptor';

   async function bootstrap() {
     const app = await NestFactory.create(AppModule);
     const configService = app.get(ConfigService);
     const logger = new Logger('Bootstrap');

     // 보안 미들웨어
     app.use(helmet());
     app.use(compression());

     // CORS 설정
     app.enableCors({
       origin: configService.get<string[]>('app.corsOrigins'),
       credentials: true,
     });

     // 글로벌 프리픽스
     app.setGlobalPrefix(configService.get<string>('app.apiPrefix'));

     // 글로벌 파이프
     app.useGlobalPipes(
       new ValidationPipe({
         whitelist: true,
         forbidNonWhitelisted: true,
         transform: true,
         transformOptions: {
           enableImplicitConversion: true,
         },
       }),
     );

     // 글로벌 필터
     app.useGlobalFilters(new AllExceptionsFilter());

     // 글로벌 인터셉터
     app.useGlobalInterceptors(
       new LoggingInterceptor(),
       new TransformInterceptor(),
     );

     const port = configService.get<number>('app.port');
     await app.listen(port);

     logger.log(`Application is running on: http://localhost:${port}`);
     logger.log(
       `API prefix: ${configService.get<string>('app.apiPrefix')}`,
     );
   }

   bootstrap();
   ```

4. **Rate Limiting 설정**
   ```typescript
   // src/app.module.ts
   import { Module } from '@nestjs/common';
   import { ConfigModule } from '@nestjs/config';
   import { ThrottlerModule } from '@nestjs/throttler';
   import { PrismaModule } from './prisma/prisma.module';
   import { MongodbModule } from './database/mongodb/mongodb.module';
   import { RedisConfigModule } from './database/redis/redis.module';
   import { EventsModule } from './events/events.module';
   import databaseConfig from './config/database.config';
   import jwtConfig from './config/jwt.config';
   import appConfig from './config/app.config';

   @Module({
     imports: [
       ConfigModule.forRoot({
         isGlobal: true,
         load: [databaseConfig, jwtConfig, appConfig],
       }),
       ThrottlerModule.forRoot([
         {
           ttl: 60000, // 1분
           limit: 100, // 100개 요청
         },
       ]),
       PrismaModule,
       MongodbModule,
       RedisConfigModule,
       EventsModule,
     ],
   })
   export class AppModule {}
   ```

**검증 항목**:
- [ ] JWT 인증 가드 작성 완료
- [ ] 역할 기반 가드 작성 완료
- [ ] 보안 미들웨어 설정 완료
- [ ] Rate Limiting 테스트

---

#### Day 19-20: Swagger API 문서화 및 헬스체크

**목표**: API 문서 자동화 및 모니터링 엔드포인트

**작업 순서**:

1. **Swagger 설정**
   ```typescript
   // src/config/swagger.config.ts
   import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';
   import { INestApplication } from '@nestjs/common';

   export function setupSwagger(app: INestApplication): void {
     const config = new DocumentBuilder()
       .setTitle('중고거래사이트 API')
       .setDescription('중고거래 플랫폼 백엔드 API 문서')
       .setVersion('1.0')
       .addBearerAuth(
         {
           type: 'http',
           scheme: 'bearer',
           bearerFormat: 'JWT',
           name: 'JWT',
           description: 'JWT 토큰을 입력하세요',
           in: 'header',
         },
         'access-token',
       )
       .addTag('Auth', '인증/인가 관련 API')
       .addTag('Users', '사용자 관리 API')
       .addTag('Products', '상품 관리 API')
       .addTag('Orders', '주문 관리 API')
       .addTag('Categories', '카테고리 관리 API')
       .build();

     const document = SwaggerModule.createDocument(app, config);
     SwaggerModule.setup('api-docs', app, document, {
       swaggerOptions: {
         persistAuthorization: true,
       },
     });
   }
   ```

   ```typescript
   // src/main.ts에 추가
   import { setupSwagger } from './config/swagger.config';

   async function bootstrap() {
     // ... 기존 코드

     // Swagger 설정
     setupSwagger(app);

     const port = configService.get<number>('app.port');
     await app.listen(port);

     logger.log(`API Documentation: http://localhost:${port}/api-docs`);
   }
   ```

2. **헬스체크 모듈 작성**
   ```typescript
   // src/health/health.controller.ts
   import { Controller, Get } from '@nestjs/common';
   import { ApiTags, ApiOperation } from '@nestjs/swagger';
   import {
     HealthCheck,
     HealthCheckService,
     PrismaHealthIndicator,
     MongooseHealthIndicator,
   } from '@nestjs/terminus';
   import { PrismaService } from '../prisma/prisma.service';
   import { Public } from '../common/decorators/public.decorator';

   @ApiTags('Health')
   @Controller('health')
   export class HealthController {
     constructor(
       private health: HealthCheckService,
       private prismaHealth: PrismaHealthIndicator,
       private mongooseHealth: MongooseHealthIndicator,
       private prisma: PrismaService,
     ) {}

     @Get()
     @Public()
     @HealthCheck()
     @ApiOperation({ summary: '전체 헬스체크' })
     check() {
       return this.health.check([
         () => this.prismaHealth.pingCheck('postgresql', this.prisma),
         () => this.mongooseHealth.pingCheck('mongodb'),
       ]);
     }
   }
   ```

**검증 항목**:
- [ ] Swagger 문서 접속 확인 (http://localhost:3000/api-docs)
- [ ] 헬스체크 엔드포인트 테스트 (GET /health)
- [ ] API 문서 자동 생성 확인

---

## ✅ Phase 1 완료 체크리스트

### Week 1 체크리스트
- [ ] Docker Compose 환경 구축 완료
- [ ] 모든 데이터베이스 컨테이너 정상 동작
- [ ] 프로젝트 폴더 구조 생성
- [ ] 공통 모듈(interceptor, filter, pipe, decorator) 작성 완료
- [ ] 환경 변수 설정 완료

### Week 2 체크리스트
- [ ] Prisma 스키마 작성 및 마이그레이션 완료
- [ ] PrismaService 모듈 생성
- [ ] MongoDB 스키마 작성
- [ ] MongoDB 연결 모듈 생성
- [ ] Redis 연결 모듈 생성

### Week 3 체크리스트
- [ ] RabbitMQ 이벤트 시스템 구축
- [ ] 이벤트 발행/구독 테스트
- [ ] **Winston 로거 설정 완료** ⭐
- [ ] 로그 파일 생성 및 로테이션 테스트
- [ ] 민감정보 마스킹 검증
- [ ] 공통 유틸리티 함수 작성
- [ ] 공통 DTO 클래스 작성

### Week 4 체크리스트
- [ ] JWT 인증 가드 작성
- [ ] 역할 기반 가드 작성
- [ ] 보안 미들웨어 설정
- [ ] Rate Limiting 설정
- [ ] Swagger 문서화 설정
- [ ] 헬스체크 엔드포인트 작성

---

## 🚀 Phase 2: 핵심 비즈니스 로직 구현 (5-10주)

> **다음 단계 계획**
> Phase 1 보일러플레이트가 완성되면, Phase 2에서는 다음 순서로 비즈니스 로직을 구현합니다:
>
> 1. **Week 5-6**: 사용자 인증/인가 시스템 (회원가입, 로그인, JWT, OAuth)
> 2. **Week 7-8**: 상품 관리 시스템 (CRUD, 파일 업로드, 검색)
> 3. **Week 9-10**: 주문 및 결제 시스템 (주문 생성, 결제 연동, Saga 패턴)

---

## 📝 다음 단계 진행 가이드

### Phase 1 완료 후 진행 순서

1. **보일러플레이트 검증**
   - 모든 데이터베이스 연결 테스트
   - 공통 모듈 동작 확인
   - API 헬스체크 통과

2. **Phase 2 준비**
   - 인증 모듈 비즈니스 로직 설계 문서 작성
   - API 명세서 작성
   - 테스트 시나리오 작성

3. **개발 시작**
   - Week 5부터 사용자 인증 비즈니스 로직 구현
   - TDD 방식으로 테스트 코드 먼저 작성
   - 단위 테스트 → 통합 테스트 순서로 진행

---

## 📊 성공 지표

### Phase 1 완료 기준
- [ ] Docker 환경에서 모든 서비스 정상 실행
- [ ] 데이터베이스 연결 100% 성공
- [ ] **Winston 로거 정상 동작 및 파일 로깅 확인** ⭐
- [ ] Swagger 문서 자동 생성
- [ ] 헬스체크 API 정상 응답
- [ ] 보안 미들웨어 적용 완료
- [ ] 단위 테스트 커버리지 >70%

---

**문서 버전**: v1.0
**작성일**: 2025-10-15
**다음 리뷰**: Phase 1 완료 후
**승인 필요**: 개발팀, PM
