# AMQP ì§ì ‘ êµ¬í˜„ ê°€ì´ë“œ (amqplib)

## ğŸ“‹ ë¬¸ì„œ ì •ë³´

- **í”„ë¡œì íŠ¸**: ì¤‘ê³ ê±°ë˜ì‚¬ì´íŠ¸ ë°±ì—”ë“œ API
- **ì‘ì„±ì¼**: 2025-10-15
- **ëª©ì **: amqplibë¥¼ ì‚¬ìš©í•œ RabbitMQ ì§ì ‘ êµ¬í˜„ ê°€ì´ë“œ

---

## ğŸ¯ êµ¬í˜„ ëª©í‘œ

1. **ì•ˆì •ì ì¸ ì—°ê²° ê´€ë¦¬**: ìë™ ì¬ì—°ê²° ë° ì—ëŸ¬ í•¸ë“¤ë§
2. **Dead Letter Queue**: ì‹¤íŒ¨í•œ ë©”ì‹œì§€ ì²˜ë¦¬
3. **Saga íŒ¨í„´ ì§€ì›**: ë¶„ì‚° íŠ¸ëœì­ì…˜ êµ¬í˜„
4. **ìš°ì„ ìˆœìœ„ í**: ì‘ì—… ìš°ì„ ìˆœìœ„ ê´€ë¦¬
5. **ì„±ëŠ¥ ìµœì í™”**: Prefetch, ë°°ì¹˜ ì²˜ë¦¬

---

## ğŸ“¦ íŒ¨í‚¤ì§€ ì„¤ì¹˜

```bash
# AMQP ë¼ì´ë¸ŒëŸ¬ë¦¬
pnpm add amqplib amqp-connection-manager

# íƒ€ì… ì •ì˜
pnpm add -D @types/amqplib

# ê¸°ì¡´ NestJS Microservices ì œê±° (ì„ íƒ)
pnpm remove @nestjs/microservices
```

---

## ğŸ—ï¸ êµ¬í˜„ ë‹¨ê³„

### Step 1: RabbitMQ ì—°ê²° ê´€ë¦¬ ì„œë¹„ìŠ¤

```typescript
// src/rabbitmq/rabbitmq-connection.service.ts
import { Injectable, OnModuleInit, OnModuleDestroy, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import * as amqp from 'amqp-connection-manager';
import { ChannelWrapper } from 'amqp-connection-manager';
import { ConfirmChannel } from 'amqplib';

@Injectable()
export class RabbitMQConnectionService implements OnModuleInit, OnModuleDestroy {
  private readonly logger = new Logger(RabbitMQConnectionService.name);
  private connection: amqp.AmqpConnectionManager;
  private channelWrapper: ChannelWrapper;

  constructor(private configService: ConfigService) {}

  async onModuleInit() {
    await this.connect();
  }

  async onModuleDestroy() {
    await this.disconnect();
  }

  /**
   * RabbitMQ ì—°ê²° ìƒì„±
   */
  private async connect(): Promise<void> {
    const url = this.configService.get<string>('RABBITMQ_URL') || 'amqp://localhost';

    this.logger.log(`RabbitMQ ì—°ê²° ì‹œì‘: ${url}`);

    // ì—°ê²° ê´€ë¦¬ì ìƒì„± (ìë™ ì¬ì—°ê²°)
    this.connection = amqp.connect([url], {
      heartbeatIntervalInSeconds: 30,
      reconnectTimeInSeconds: 1,
    });

    // ì—°ê²° ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
    this.connection.on('connect', () => {
      this.logger.log('âœ… RabbitMQ ì—°ê²° ì„±ê³µ');
    });

    this.connection.on('disconnect', (err) => {
      this.logger.error('âŒ RabbitMQ ì—°ê²° ëŠê¹€', err.err);
    });

    this.connection.on('connectFailed', (err) => {
      this.logger.error('âŒ RabbitMQ ì—°ê²° ì‹¤íŒ¨', err.err);
    });

    // ì±„ë„ ë˜í¼ ìƒì„±
    this.channelWrapper = this.connection.createChannel({
      json: false, // Bufferë¡œ ì²˜ë¦¬
      setup: async (channel: ConfirmChannel) => {
        await this.setupInfrastructure(channel);
      },
    });

    this.channelWrapper.on('error', (err) => {
      this.logger.error('ì±„ë„ ì—ëŸ¬', err);
    });

    this.channelWrapper.on('close', () => {
      this.logger.warn('ì±„ë„ ë‹«í˜');
    });

    await this.channelWrapper.waitForConnect();
    this.logger.log('âœ… RabbitMQ ì´ˆê¸°í™” ì™„ë£Œ');
  }

  /**
   * Exchange, Queue, Binding ì„¤ì •
   */
  private async setupInfrastructure(channel: ConfirmChannel): Promise<void> {
    this.logger.log('RabbitMQ ì¸í”„ë¼ ì„¤ì • ì‹œì‘...');

    // ========================================
    // 1. Main Exchange ì„¤ì •
    // ========================================
    await channel.assertExchange('events', 'topic', {
      durable: true,
    });

    await channel.assertExchange('commands', 'direct', {
      durable: true,
    });

    // ========================================
    // 2. Dead Letter Exchange ì„¤ì •
    // ========================================
    await channel.assertExchange('events-dlx', 'topic', {
      durable: true,
    });

    // ========================================
    // 3. ì£¼ë¬¸ ê´€ë ¨ í
    // ========================================

    // ì£¼ë¬¸ ì´ë²¤íŠ¸ í
    await channel.assertQueue('orders-queue', {
      durable: true,
      deadLetterExchange: 'events-dlx',
      deadLetterRoutingKey: 'orders.failed',
      messageTtl: 3600000, // 1ì‹œê°„
    });

    await channel.bindQueue('orders-queue', 'events', 'order.*');

    // ì£¼ë¬¸ DLQ
    await channel.assertQueue('orders-dlq', {
      durable: true,
    });

    await channel.bindQueue('orders-dlq', 'events-dlx', 'orders.failed');

    // ========================================
    // 4. ê²°ì œ ê´€ë ¨ í
    // ========================================

    await channel.assertQueue('payments-queue', {
      durable: true,
      deadLetterExchange: 'events-dlx',
      deadLetterRoutingKey: 'payments.failed',
    });

    await channel.bindQueue('payments-queue', 'events', 'payment.*');

    await channel.assertQueue('payments-dlq', {
      durable: true,
    });

    await channel.bindQueue('payments-dlq', 'events-dlx', 'payments.failed');

    // ========================================
    // 5. ì•Œë¦¼ ê´€ë ¨ í (ìš°ì„ ìˆœìœ„)
    // ========================================

    await channel.assertQueue('notifications-queue', {
      durable: true,
      maxPriority: 10, // ìš°ì„ ìˆœìœ„ í
      deadLetterExchange: 'events-dlx',
      deadLetterRoutingKey: 'notifications.failed',
    });

    await channel.bindQueue('notifications-queue', 'events', 'notification.*');

    // ========================================
    // 6. ì´ë¯¸ì§€ ì²˜ë¦¬ í
    // ========================================

    await channel.assertQueue('image-processing-queue', {
      durable: true,
      maxPriority: 5,
    });

    await channel.bindQueue('image-processing-queue', 'events', 'image.*');

    this.logger.log('âœ… RabbitMQ ì¸í”„ë¼ ì„¤ì • ì™„ë£Œ');
  }

  /**
   * ì—°ê²° ì¢…ë£Œ
   */
  private async disconnect(): Promise<void> {
    this.logger.log('RabbitMQ ì—°ê²° ì¢…ë£Œ ì¤‘...');

    if (this.channelWrapper) {
      await this.channelWrapper.close();
    }

    if (this.connection) {
      await this.connection.close();
    }

    this.logger.log('âœ… RabbitMQ ì—°ê²° ì¢…ë£Œ ì™„ë£Œ');
  }

  /**
   * ì±„ë„ ë˜í¼ ê°€ì ¸ì˜¤ê¸°
   */
  getChannelWrapper(): ChannelWrapper {
    return this.channelWrapper;
  }

  /**
   * ì—°ê²° ìƒíƒœ í™•ì¸
   */
  isConnected(): boolean {
    return this.connection?.isConnected() || false;
  }
}
```

---

### Step 2: Producer ì„œë¹„ìŠ¤ (ë©”ì‹œì§€ ë°œí–‰)

```typescript
// src/rabbitmq/rabbitmq-producer.service.ts
import { Injectable, Inject, Logger } from '@nestjs/common';
import { RabbitMQConnectionService } from './rabbitmq-connection.service';
import { v4 as uuidv4 } from 'uuid';

export interface PublishOptions {
  priority?: number; // 0-10
  persistent?: boolean;
  expiration?: string; // TTL in ms
  correlationId?: string;
  replyTo?: string;
  headers?: Record<string, any>;
}

@Injectable()
export class RabbitMQProducerService {
  private readonly logger = new Logger(RabbitMQProducerService.name);

  constructor(
    private readonly connectionService: RabbitMQConnectionService,
  ) {}

  /**
   * ì´ë²¤íŠ¸ ë°œí–‰ (topic exchange)
   */
  async publishEvent(
    routingKey: string,
    data: any,
    options?: PublishOptions,
  ): Promise<boolean> {
    try {
      const channel = this.connectionService.getChannelWrapper();

      const messageId = uuidv4();
      const timestamp = Date.now();

      const message = {
        id: messageId,
        timestamp,
        data,
      };

      const buffer = Buffer.from(JSON.stringify(message));

      const publishOptions = {
        persistent: options?.persistent ?? true,
        messageId,
        timestamp,
        priority: options?.priority,
        expiration: options?.expiration,
        correlationId: options?.correlationId,
        replyTo: options?.replyTo,
        headers: options?.headers || {},
      };

      await channel.publish('events', routingKey, buffer, publishOptions);

      this.logger.log(
        `ğŸ“¤ ì´ë²¤íŠ¸ ë°œí–‰: ${routingKey} | MessageId: ${messageId}`,
      );

      return true;
    } catch (error) {
      this.logger.error(
        `ì´ë²¤íŠ¸ ë°œí–‰ ì‹¤íŒ¨: ${routingKey}`,
        error.stack,
      );
      throw error;
    }
  }

  /**
   * ì»¤ë§¨ë“œ ë°œí–‰ (direct exchange)
   */
  async publishCommand(
    command: string,
    data: any,
    options?: PublishOptions,
  ): Promise<boolean> {
    try {
      const channel = this.connectionService.getChannelWrapper();

      const messageId = uuidv4();
      const message = {
        id: messageId,
        command,
        timestamp: Date.now(),
        data,
      };

      const buffer = Buffer.from(JSON.stringify(message));

      await channel.publish('commands', command, buffer, {
        persistent: options?.persistent ?? true,
        messageId,
        ...options,
      });

      this.logger.log(`ğŸ“¤ ì»¤ë§¨ë“œ ë°œí–‰: ${command} | MessageId: ${messageId}`);

      return true;
    } catch (error) {
      this.logger.error(`ì»¤ë§¨ë“œ ë°œí–‰ ì‹¤íŒ¨: ${command}`, error.stack);
      throw error;
    }
  }

  /**
   * ìš°ì„ ìˆœìœ„ ì•Œë¦¼ ë°œì†¡
   */
  async publishNotification(
    type: string,
    data: any,
    priority: number = 5,
  ): Promise<boolean> {
    return this.publishEvent(`notification.${type}`, data, {
      priority,
      persistent: true,
    });
  }

  /**
   * ë°°ì¹˜ ë°œí–‰ (ì—¬ëŸ¬ ë©”ì‹œì§€ ë™ì‹œ ë°œí–‰)
   */
  async publishBatch(
    messages: Array<{ routingKey: string; data: any; options?: PublishOptions }>,
  ): Promise<boolean> {
    try {
      const promises = messages.map((msg) =>
        this.publishEvent(msg.routingKey, msg.data, msg.options),
      );

      await Promise.all(promises);

      this.logger.log(`ğŸ“¤ ë°°ì¹˜ ë°œí–‰ ì™„ë£Œ: ${messages.length}ê°œ ë©”ì‹œì§€`);

      return true;
    } catch (error) {
      this.logger.error('ë°°ì¹˜ ë°œí–‰ ì‹¤íŒ¨', error.stack);
      throw error;
    }
  }
}
```

---

### Step 3: Consumer ì„œë¹„ìŠ¤ (ë©”ì‹œì§€ ì†Œë¹„)

```typescript
// src/rabbitmq/rabbitmq-consumer.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { RabbitMQConnectionService } from './rabbitmq-connection.service';
import { ConsumeMessage } from 'amqplib';

export interface ConsumerOptions {
  prefetch?: number;
  noAck?: boolean;
  priority?: number;
}

export type MessageHandler = (data: any, message: ConsumeMessage) => Promise<void>;

@Injectable()
export class RabbitMQConsumerService {
  private readonly logger = new Logger(RabbitMQConsumerService.name);

  constructor(
    private readonly connectionService: RabbitMQConnectionService,
  ) {}

  /**
   * ë©”ì‹œì§€ ì†Œë¹„ ì‹œì‘
   */
  async consume(
    queueName: string,
    handler: MessageHandler,
    options?: ConsumerOptions,
  ): Promise<void> {
    const channel = this.connectionService.getChannelWrapper();

    // Prefetch ì„¤ì • (í•œ ë²ˆì— ì²˜ë¦¬í•  ë©”ì‹œì§€ ìˆ˜)
    if (options?.prefetch) {
      await channel.prefetch(options.prefetch);
    }

    await channel.consume(
      queueName,
      async (message: ConsumeMessage | null) => {
        if (!message) {
          this.logger.warn(`íê°€ ë¹„ì–´ìˆìŒ: ${queueName}`);
          return;
        }

        try {
          // ë©”ì‹œì§€ íŒŒì‹±
          const content = message.content.toString();
          const data = JSON.parse(content);

          this.logger.log(
            `ğŸ“¥ ë©”ì‹œì§€ ìˆ˜ì‹ : ${queueName} | MessageId: ${message.properties.messageId}`,
          );

          // í•¸ë“¤ëŸ¬ ì‹¤í–‰
          await handler(data, message);

          // ìˆ˜ë™ ACK
          if (!options?.noAck) {
            channel.ack(message);
            this.logger.log(`âœ… ACK: ${message.properties.messageId}`);
          }
        } catch (error) {
          this.logger.error(
            `ë©”ì‹œì§€ ì²˜ë¦¬ ì‹¤íŒ¨: ${queueName} | MessageId: ${message.properties.messageId}`,
            error.stack,
          );

          // ì¬ì‹œë„ ë¡œì§
          await this.handleFailedMessage(channel, message, error);
        }
      },
      {
        noAck: options?.noAck ?? false,
        priority: options?.priority,
      },
    );

    this.logger.log(`ğŸ¯ Consumer ì‹œì‘: ${queueName}`);
  }

  /**
   * ì‹¤íŒ¨í•œ ë©”ì‹œì§€ ì²˜ë¦¬
   */
  private async handleFailedMessage(
    channel: any,
    message: ConsumeMessage,
    error: Error,
  ): Promise<void> {
    const retryCount = message.properties.headers?.['x-retry-count'] || 0;
    const maxRetries = 3;

    if (retryCount < maxRetries) {
      // ì¬ì‹œë„
      this.logger.warn(
        `ì¬ì‹œë„: ${message.properties.messageId} | ì‹œë„: ${retryCount + 1}/${maxRetries}`,
      );

      // ì›ë³¸ íë¡œ ë‹¤ì‹œ ë°œí–‰ (ì¬ì‹œë„ ì¹´ìš´íŠ¸ ì¦ê°€)
      await channel.publish(
        message.fields.exchange,
        message.fields.routingKey,
        message.content,
        {
          ...message.properties,
          headers: {
            ...message.properties.headers,
            'x-retry-count': retryCount + 1,
            'x-original-error': error.message,
          },
        },
      );

      // NACK (ì¬íí•˜ì§€ ì•ŠìŒ)
      channel.nack(message, false, false);
    } else {
      // ìµœëŒ€ ì¬ì‹œë„ ì´ˆê³¼ â†’ Dead Letter Queueë¡œ ì´ë™
      this.logger.error(
        `ìµœëŒ€ ì¬ì‹œë„ ì´ˆê³¼: ${message.properties.messageId} â†’ DLQ`,
      );

      // NACK (requeue = false) â†’ DLXë¡œ ìë™ ì´ë™
      channel.nack(message, false, false);
    }
  }

  /**
   * Dead Letter Queue ì†Œë¹„
   */
  async consumeDLQ(
    dlqName: string,
    handler: MessageHandler,
  ): Promise<void> {
    await this.consume(dlqName, async (data, message) => {
      this.logger.warn(
        `ğŸ’€ DLQ ë©”ì‹œì§€ ì²˜ë¦¬: ${dlqName} | MessageId: ${message.properties.messageId}`,
      );

      // ì˜êµ¬ ì‹¤íŒ¨ ì²˜ë¦¬ (ë¡œê¹…, ì•Œë¦¼, ìˆ˜ë™ ê°œì… ë“±)
      await handler(data, message);
    });
  }
}
```

---

### Step 4: Saga íŒ¨í„´ êµ¬í˜„

```typescript
// src/rabbitmq/saga/order-saga.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { RabbitMQProducerService } from '../rabbitmq-producer.service';
import { RabbitMQConsumerService } from '../rabbitmq-consumer.service';

export interface OrderSagaData {
  orderId: number;
  userId: number;
  productId: number;
  quantity: number;
  amount: number;
}

export enum SagaStep {
  ORDER_CREATED = 'order.created',
  INVENTORY_RESERVED = 'inventory.reserved',
  PAYMENT_PROCESSED = 'payment.processed',
  SHIPMENT_STARTED = 'shipment.started',
  SAGA_COMPLETED = 'saga.completed',
}

export enum CompensationStep {
  SHIPMENT_CANCELLED = 'shipment.cancelled',
  PAYMENT_REFUNDED = 'payment.refunded',
  INVENTORY_RELEASED = 'inventory.released',
  ORDER_CANCELLED = 'order.cancelled',
}

@Injectable()
export class OrderSagaService {
  private readonly logger = new Logger(OrderSagaService.name);

  constructor(
    private readonly producer: RabbitMQProducerService,
    private readonly consumer: RabbitMQConsumerService,
  ) {}

  /**
   * Saga ì‹œì‘
   */
  async startSaga(data: OrderSagaData): Promise<void> {
    this.logger.log(`ğŸ¬ Saga ì‹œì‘: Order ${data.orderId}`);

    try {
      // Step 1: ì£¼ë¬¸ ìƒì„± ì´ë²¤íŠ¸
      await this.producer.publishEvent(SagaStep.ORDER_CREATED, {
        ...data,
        sagaId: `saga-${data.orderId}`,
        timestamp: Date.now(),
      });

      this.logger.log(`âœ… Saga Step 1 ì™„ë£Œ: ${SagaStep.ORDER_CREATED}`);
    } catch (error) {
      this.logger.error('Saga ì‹œì‘ ì‹¤íŒ¨', error.stack);
      throw error;
    }
  }

  /**
   * Saga ë³´ìƒ íŠ¸ëœì­ì…˜ (Rollback)
   */
  async compensate(data: OrderSagaData, failedStep: string): Promise<void> {
    this.logger.warn(
      `âš ï¸  Saga ë³´ìƒ ì‹œì‘: Order ${data.orderId} | ì‹¤íŒ¨ ë‹¨ê³„: ${failedStep}`,
    );

    try {
      // ì—­ìˆœìœ¼ë¡œ ë³´ìƒ
      if (failedStep === SagaStep.SHIPMENT_STARTED) {
        await this.producer.publishEvent(CompensationStep.SHIPMENT_CANCELLED, data);
      }

      if (
        failedStep === SagaStep.PAYMENT_PROCESSED ||
        failedStep === SagaStep.SHIPMENT_STARTED
      ) {
        await this.producer.publishEvent(CompensationStep.PAYMENT_REFUNDED, data);
      }

      if (
        failedStep === SagaStep.INVENTORY_RESERVED ||
        failedStep === SagaStep.PAYMENT_PROCESSED ||
        failedStep === SagaStep.SHIPMENT_STARTED
      ) {
        await this.producer.publishEvent(CompensationStep.INVENTORY_RELEASED, data);
      }

      // í•­ìƒ ì£¼ë¬¸ ì·¨ì†Œ
      await this.producer.publishEvent(CompensationStep.ORDER_CANCELLED, data);

      this.logger.log(`âœ… Saga ë³´ìƒ ì™„ë£Œ: Order ${data.orderId}`);
    } catch (error) {
      this.logger.error('Saga ë³´ìƒ ì‹¤íŒ¨', error.stack);
      // ìˆ˜ë™ ê°œì… í•„ìš” ì•Œë¦¼
      await this.notifyManualIntervention(data, error);
    }
  }

  /**
   * ìˆ˜ë™ ê°œì… ì•Œë¦¼
   */
  private async notifyManualIntervention(
    data: OrderSagaData,
    error: Error,
  ): Promise<void> {
    await this.producer.publishNotification(
      'manual-intervention',
      {
        orderId: data.orderId,
        error: error.message,
        timestamp: Date.now(),
      },
      10, // ìµœê³  ìš°ì„ ìˆœìœ„
    );
  }

  /**
   * Saga Consumer ì‹œì‘
   */
  async startConsumers(): Promise<void> {
    // Order Created ì²˜ë¦¬
    await this.consumer.consume(
      'orders-queue',
      async (data) => {
        await this.handleOrderCreated(data);
      },
      { prefetch: 1 }, // ìˆœì„œ ë³´ì¥ì„ ìœ„í•´ 1ê°œì”©
    );

    // Inventory Reserved ì²˜ë¦¬
    await this.consumer.consume(
      'inventory-queue',
      async (data) => {
        await this.handleInventoryReserved(data);
      },
      { prefetch: 1 },
    );

    // Payment Processed ì²˜ë¦¬
    await this.consumer.consume(
      'payments-queue',
      async (data) => {
        await this.handlePaymentProcessed(data);
      },
      { prefetch: 1 },
    );

    this.logger.log('ğŸ¯ Saga Consumers ì‹œì‘ ì™„ë£Œ');
  }

  private async handleOrderCreated(data: any): Promise<void> {
    this.logger.log(`ì²˜ë¦¬: ${SagaStep.ORDER_CREATED}`);

    // ì¬ê³  í™•ì¸ ì´ë²¤íŠ¸ ë°œí–‰
    await this.producer.publishEvent(SagaStep.INVENTORY_RESERVED, data);
  }

  private async handleInventoryReserved(data: any): Promise<void> {
    this.logger.log(`ì²˜ë¦¬: ${SagaStep.INVENTORY_RESERVED}`);

    // ê²°ì œ ì²˜ë¦¬ ì´ë²¤íŠ¸ ë°œí–‰
    await this.producer.publishEvent(SagaStep.PAYMENT_PROCESSED, data);
  }

  private async handlePaymentProcessed(data: any): Promise<void> {
    this.logger.log(`ì²˜ë¦¬: ${SagaStep.PAYMENT_PROCESSED}`);

    // ë°°ì†¡ ì‹œì‘ ì´ë²¤íŠ¸ ë°œí–‰
    await this.producer.publishEvent(SagaStep.SHIPMENT_STARTED, data);
  }
}
```

---

### Step 5: RabbitMQ ëª¨ë“ˆ í†µí•©

```typescript
// src/rabbitmq/rabbitmq.module.ts
import { Module, Global } from '@nestjs/common';
import { RabbitMQConnectionService } from './rabbitmq-connection.service';
import { RabbitMQProducerService } from './rabbitmq-producer.service';
import { RabbitMQConsumerService } from './rabbitmq-consumer.service';
import { OrderSagaService } from './saga/order-saga.service';

@Global()
@Module({
  providers: [
    RabbitMQConnectionService,
    RabbitMQProducerService,
    RabbitMQConsumerService,
    OrderSagaService,
  ],
  exports: [
    RabbitMQConnectionService,
    RabbitMQProducerService,
    RabbitMQConsumerService,
    OrderSagaService,
  ],
})
export class RabbitMQModule {}
```

---

### Step 6: AppModuleì— ë“±ë¡

```typescript
// src/app.module.ts
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { RabbitMQModule } from './rabbitmq/rabbitmq.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
    }),
    RabbitMQModule, // RabbitMQ ëª¨ë“ˆ ë“±ë¡
    // ... ë‹¤ë¥¸ ëª¨ë“ˆë“¤
  ],
})
export class AppModule {}
```

---

## ğŸ¯ ì‚¬ìš© ì˜ˆì œ

### 1. ì£¼ë¬¸ ìƒì„± ì‹œ ì´ë²¤íŠ¸ ë°œí–‰

```typescript
// src/modules/orders/orders.service.ts
import { Injectable } from '@nestjs/common';
import { RabbitMQProducerService } from '../../rabbitmq/rabbitmq-producer.service';
import { OrderSagaService } from '../../rabbitmq/saga/order-saga.service';

@Injectable()
export class OrdersService {
  constructor(
    private readonly producer: RabbitMQProducerService,
    private readonly saga: OrderSagaService,
  ) {}

  async createOrder(data: CreateOrderDto) {
    // ì£¼ë¬¸ ìƒì„±
    const order = await this.prisma.order.create({ data });

    // Saga ì‹œì‘
    await this.saga.startSaga({
      orderId: order.id,
      userId: order.buyerId,
      productId: data.productId,
      quantity: data.quantity,
      amount: order.totalAmount,
    });

    return order;
  }
}
```

### 2. ì•Œë¦¼ ë°œì†¡ (ìš°ì„ ìˆœìœ„)

```typescript
// src/modules/notifications/notifications.service.ts
@Injectable()
export class NotificationsService {
  constructor(private readonly producer: RabbitMQProducerService) {}

  async sendUrgentNotification(userId: number, message: string) {
    // ê¸´ê¸‰ ì•Œë¦¼ (ìš°ì„ ìˆœìœ„ 10)
    await this.producer.publishNotification(
      'urgent',
      { userId, message },
      10,
    );
  }

  async sendNormalNotification(userId: number, message: string) {
    // ì¼ë°˜ ì•Œë¦¼ (ìš°ì„ ìˆœìœ„ 5)
    await this.producer.publishNotification(
      'normal',
      { userId, message },
      5,
    );
  }
}
```

### 3. Consumer ì‹œì‘

```typescript
// src/main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { OrderSagaService } from './rabbitmq/saga/order-saga.service';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // Saga Consumers ì‹œì‘
  const sagaService = app.get(OrderSagaService);
  await sagaService.startConsumers();

  await app.listen(3000);
}

bootstrap();
```

---

## âœ… ê²€ì¦ ë° í…ŒìŠ¤íŠ¸

### 1. ì—°ê²° í…ŒìŠ¤íŠ¸

```bash
# ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹œì‘
pnpm run start:dev

# ë¡œê·¸ í™•ì¸
# âœ… RabbitMQ ì—°ê²° ì„±ê³µ
# âœ… RabbitMQ ì´ˆê¸°í™” ì™„ë£Œ
# ğŸ¯ Saga Consumers ì‹œì‘ ì™„ë£Œ
```

### 2. RabbitMQ Management UI í™•ì¸

```bash
# ë¸Œë¼ìš°ì €ì—ì„œ ì ‘ì†
http://localhost:15672

# ê³„ì •: rabbit / rabbit123

# í™•ì¸ ì‚¬í•­:
# - Exchanges: events, commands, events-dlx
# - Queues: orders-queue, payments-queue, notifications-queue ë“±
# - Bindings: ì •ìƒì ìœ¼ë¡œ ë°”ì¸ë”©ë˜ì–´ ìˆëŠ”ì§€
```

### 3. ë©”ì‹œì§€ ë°œí–‰ í…ŒìŠ¤íŠ¸

```typescript
// í…ŒìŠ¤íŠ¸ ì—”ë“œí¬ì¸íŠ¸
@Get('test/publish')
async testPublish() {
  await this.producer.publishEvent('order.created', {
    orderId: 1,
    userId: 1,
    amount: 10000,
  });

  return { message: 'Event published' };
}
```

---

## ğŸ“Š ëª¨ë‹ˆí„°ë§ ë° ê´€ë¦¬

### 1. RabbitMQ ë©”íŠ¸ë¦­ ìˆ˜ì§‘

```typescript
// src/rabbitmq/rabbitmq-metrics.service.ts
@Injectable()
export class RabbitMQMetricsService {
  async getQueueMetrics(queueName: string) {
    // RabbitMQ HTTP API í˜¸ì¶œ
    const response = await axios.get(
      `http://localhost:15672/api/queues/%2F/${queueName}`,
      {
        auth: {
          username: 'rabbit',
          password: 'rabbit123',
        },
      },
    );

    return {
      messages: response.data.messages,
      messagesReady: response.data.messages_ready,
      messagesUnacknowledged: response.data.messages_unacknowledged,
      consumers: response.data.consumers,
    };
  }
}
```

### 2. í—¬ìŠ¤ì²´í¬

```typescript
// src/health/rabbitmq-health.indicator.ts
import { Injectable } from '@nestjs/common';
import { HealthIndicator, HealthIndicatorResult } from '@nestjs/terminus';
import { RabbitMQConnectionService } from '../rabbitmq/rabbitmq-connection.service';

@Injectable()
export class RabbitMQHealthIndicator extends HealthIndicator {
  constructor(
    private readonly connectionService: RabbitMQConnectionService,
  ) {
    super();
  }

  async isHealthy(key: string): Promise<HealthIndicatorResult> {
    const isConnected = this.connectionService.isConnected();

    if (isConnected) {
      return this.getStatus(key, true);
    }

    return this.getStatus(key, false, {
      message: 'RabbitMQ connection is down',
    });
  }
}
```

---

## ğŸš€ ë‹¤ìŒ ë‹¨ê³„

1. **Week 3**: ê¸°ë³¸ AMQP êµ¬í˜„ ì™„ë£Œ
2. **Week 4**: Dead Letter Queue ë° ì¬ì‹œë„ ë¡œì§ í…ŒìŠ¤íŠ¸
3. **Week 9**: Saga íŒ¨í„´ ì‹¤ì „ ì ìš© (ì£¼ë¬¸/ê²°ì œ ì›Œí¬í”Œë¡œìš°)

---

**ë¬¸ì„œ ë²„ì „**: v1.0
**ìµœì¢… ì—…ë°ì´íŠ¸**: 2025-10-15
**ì‘ì„±ì**: ê°œë°œíŒ€
