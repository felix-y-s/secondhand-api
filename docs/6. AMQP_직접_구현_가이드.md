# AMQP 직접 구현 가이드 (amqplib)

## 📋 문서 정보

- **프로젝트**: 중고거래사이트 백엔드 API
- **작성일**: 2025-10-15
- **목적**: amqplib를 사용한 RabbitMQ 직접 구현 가이드

---

## 🎯 구현 목표

1. **안정적인 연결 관리**: 자동 재연결 및 에러 핸들링
2. **Dead Letter Queue**: 실패한 메시지 처리
3. **Saga 패턴 지원**: 분산 트랜잭션 구현
4. **우선순위 큐**: 작업 우선순위 관리
5. **성능 최적화**: Prefetch, 배치 처리

---

## 📦 패키지 설치

```bash
# AMQP 라이브러리
pnpm add amqplib amqp-connection-manager

# 타입 정의
pnpm add -D @types/amqplib

# 기존 NestJS Microservices 제거 (선택)
pnpm remove @nestjs/microservices
```

---

## 🏗️ 구현 단계

### Step 1: RabbitMQ 연결 관리 서비스

```typescript
// src/rabbitmq/rabbitmq-connection.service.ts
import { Injectable, OnModuleInit, OnModuleDestroy, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import * as amqp from 'amqp-connection-manager';
import { ChannelWrapper } from 'amqp-connection-manager';
import { ConfirmChannel } from 'amqplib';

@Injectable()
export class RabbitMQConnectionService implements OnModuleInit, OnModuleDestroy {
  private readonly logger = new Logger(RabbitMQConnectionService.name);
  private connection: amqp.AmqpConnectionManager;
  private channelWrapper: ChannelWrapper;

  constructor(private configService: ConfigService) {}

  async onModuleInit() {
    await this.connect();
  }

  async onModuleDestroy() {
    await this.disconnect();
  }

  /**
   * RabbitMQ 연결 생성
   */
  private async connect(): Promise<void> {
    const url = this.configService.get<string>('RABBITMQ_URL') || 'amqp://localhost';

    this.logger.log(`RabbitMQ 연결 시작: ${url}`);

    // 연결 관리자 생성 (자동 재연결)
    this.connection = amqp.connect([url], {
      heartbeatIntervalInSeconds: 30,
      reconnectTimeInSeconds: 1,
    });

    // 연결 이벤트 리스너
    this.connection.on('connect', () => {
      this.logger.log('✅ RabbitMQ 연결 성공');
    });

    this.connection.on('disconnect', (err) => {
      this.logger.error('❌ RabbitMQ 연결 끊김', err.err);
    });

    this.connection.on('connectFailed', (err) => {
      this.logger.error('❌ RabbitMQ 연결 실패', err.err);
    });

    // 채널 래퍼 생성
    this.channelWrapper = this.connection.createChannel({
      json: false, // Buffer로 처리
      setup: async (channel: ConfirmChannel) => {
        await this.setupInfrastructure(channel);
      },
    });

    this.channelWrapper.on('error', (err) => {
      this.logger.error('채널 에러', err);
    });

    this.channelWrapper.on('close', () => {
      this.logger.warn('채널 닫힘');
    });

    await this.channelWrapper.waitForConnect();
    this.logger.log('✅ RabbitMQ 초기화 완료');
  }

  /**
   * Exchange, Queue, Binding 설정
   */
  private async setupInfrastructure(channel: ConfirmChannel): Promise<void> {
    this.logger.log('RabbitMQ 인프라 설정 시작...');

    // ========================================
    // 1. Main Exchange 설정
    // ========================================
    await channel.assertExchange('events', 'topic', {
      durable: true,
    });

    await channel.assertExchange('commands', 'direct', {
      durable: true,
    });

    // ========================================
    // 2. Dead Letter Exchange 설정
    // ========================================
    await channel.assertExchange('events-dlx', 'topic', {
      durable: true,
    });

    // ========================================
    // 3. 주문 관련 큐
    // ========================================

    // 주문 이벤트 큐
    await channel.assertQueue('orders-queue', {
      durable: true,
      deadLetterExchange: 'events-dlx',
      deadLetterRoutingKey: 'orders.failed',
      messageTtl: 3600000, // 1시간
    });

    await channel.bindQueue('orders-queue', 'events', 'order.*');

    // 주문 DLQ
    await channel.assertQueue('orders-dlq', {
      durable: true,
    });

    await channel.bindQueue('orders-dlq', 'events-dlx', 'orders.failed');

    // ========================================
    // 4. 결제 관련 큐
    // ========================================

    await channel.assertQueue('payments-queue', {
      durable: true,
      deadLetterExchange: 'events-dlx',
      deadLetterRoutingKey: 'payments.failed',
    });

    await channel.bindQueue('payments-queue', 'events', 'payment.*');

    await channel.assertQueue('payments-dlq', {
      durable: true,
    });

    await channel.bindQueue('payments-dlq', 'events-dlx', 'payments.failed');

    // ========================================
    // 5. 알림 관련 큐 (우선순위)
    // ========================================

    await channel.assertQueue('notifications-queue', {
      durable: true,
      maxPriority: 10, // 우선순위 큐
      deadLetterExchange: 'events-dlx',
      deadLetterRoutingKey: 'notifications.failed',
    });

    await channel.bindQueue('notifications-queue', 'events', 'notification.*');

    // ========================================
    // 6. 이미지 처리 큐
    // ========================================

    await channel.assertQueue('image-processing-queue', {
      durable: true,
      maxPriority: 5,
    });

    await channel.bindQueue('image-processing-queue', 'events', 'image.*');

    this.logger.log('✅ RabbitMQ 인프라 설정 완료');
  }

  /**
   * 연결 종료
   */
  private async disconnect(): Promise<void> {
    this.logger.log('RabbitMQ 연결 종료 중...');

    if (this.channelWrapper) {
      await this.channelWrapper.close();
    }

    if (this.connection) {
      await this.connection.close();
    }

    this.logger.log('✅ RabbitMQ 연결 종료 완료');
  }

  /**
   * 채널 래퍼 가져오기
   */
  getChannelWrapper(): ChannelWrapper {
    return this.channelWrapper;
  }

  /**
   * 연결 상태 확인
   */
  isConnected(): boolean {
    return this.connection?.isConnected() || false;
  }
}
```

---

### Step 2: Producer 서비스 (메시지 발행)

```typescript
// src/rabbitmq/rabbitmq-producer.service.ts
import { Injectable, Inject, Logger } from '@nestjs/common';
import { RabbitMQConnectionService } from './rabbitmq-connection.service';
import { v4 as uuidv4 } from 'uuid';

export interface PublishOptions {
  priority?: number; // 0-10
  persistent?: boolean;
  expiration?: string; // TTL in ms
  correlationId?: string;
  replyTo?: string;
  headers?: Record<string, any>;
}

@Injectable()
export class RabbitMQProducerService {
  private readonly logger = new Logger(RabbitMQProducerService.name);

  constructor(
    private readonly connectionService: RabbitMQConnectionService,
  ) {}

  /**
   * 이벤트 발행 (topic exchange)
   */
  async publishEvent(
    routingKey: string,
    data: any,
    options?: PublishOptions,
  ): Promise<boolean> {
    try {
      const channel = this.connectionService.getChannelWrapper();

      const messageId = uuidv4();
      const timestamp = Date.now();

      const message = {
        id: messageId,
        timestamp,
        data,
      };

      const buffer = Buffer.from(JSON.stringify(message));

      const publishOptions = {
        persistent: options?.persistent ?? true,
        messageId,
        timestamp,
        priority: options?.priority,
        expiration: options?.expiration,
        correlationId: options?.correlationId,
        replyTo: options?.replyTo,
        headers: options?.headers || {},
      };

      await channel.publish('events', routingKey, buffer, publishOptions);

      this.logger.log(
        `📤 이벤트 발행: ${routingKey} | MessageId: ${messageId}`,
      );

      return true;
    } catch (error) {
      this.logger.error(
        `이벤트 발행 실패: ${routingKey}`,
        error.stack,
      );
      throw error;
    }
  }

  /**
   * 커맨드 발행 (direct exchange)
   */
  async publishCommand(
    command: string,
    data: any,
    options?: PublishOptions,
  ): Promise<boolean> {
    try {
      const channel = this.connectionService.getChannelWrapper();

      const messageId = uuidv4();
      const message = {
        id: messageId,
        command,
        timestamp: Date.now(),
        data,
      };

      const buffer = Buffer.from(JSON.stringify(message));

      await channel.publish('commands', command, buffer, {
        persistent: options?.persistent ?? true,
        messageId,
        ...options,
      });

      this.logger.log(`📤 커맨드 발행: ${command} | MessageId: ${messageId}`);

      return true;
    } catch (error) {
      this.logger.error(`커맨드 발행 실패: ${command}`, error.stack);
      throw error;
    }
  }

  /**
   * 우선순위 알림 발송
   */
  async publishNotification(
    type: string,
    data: any,
    priority: number = 5,
  ): Promise<boolean> {
    return this.publishEvent(`notification.${type}`, data, {
      priority,
      persistent: true,
    });
  }

  /**
   * 배치 발행 (여러 메시지 동시 발행)
   */
  async publishBatch(
    messages: Array<{ routingKey: string; data: any; options?: PublishOptions }>,
  ): Promise<boolean> {
    try {
      const promises = messages.map((msg) =>
        this.publishEvent(msg.routingKey, msg.data, msg.options),
      );

      await Promise.all(promises);

      this.logger.log(`📤 배치 발행 완료: ${messages.length}개 메시지`);

      return true;
    } catch (error) {
      this.logger.error('배치 발행 실패', error.stack);
      throw error;
    }
  }
}
```

---

### Step 3: Consumer 서비스 (메시지 소비)

```typescript
// src/rabbitmq/rabbitmq-consumer.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { RabbitMQConnectionService } from './rabbitmq-connection.service';
import { ConsumeMessage } from 'amqplib';

export interface ConsumerOptions {
  prefetch?: number;
  noAck?: boolean;
  priority?: number;
}

export type MessageHandler = (data: any, message: ConsumeMessage) => Promise<void>;

@Injectable()
export class RabbitMQConsumerService {
  private readonly logger = new Logger(RabbitMQConsumerService.name);

  constructor(
    private readonly connectionService: RabbitMQConnectionService,
  ) {}

  /**
   * 메시지 소비 시작
   */
  async consume(
    queueName: string,
    handler: MessageHandler,
    options?: ConsumerOptions,
  ): Promise<void> {
    const channel = this.connectionService.getChannelWrapper();

    // Prefetch 설정 (한 번에 처리할 메시지 수)
    if (options?.prefetch) {
      await channel.prefetch(options.prefetch);
    }

    await channel.consume(
      queueName,
      async (message: ConsumeMessage | null) => {
        if (!message) {
          this.logger.warn(`큐가 비어있음: ${queueName}`);
          return;
        }

        try {
          // 메시지 파싱
          const content = message.content.toString();
          const data = JSON.parse(content);

          this.logger.log(
            `📥 메시지 수신: ${queueName} | MessageId: ${message.properties.messageId}`,
          );

          // 핸들러 실행
          await handler(data, message);

          // 수동 ACK
          if (!options?.noAck) {
            channel.ack(message);
            this.logger.log(`✅ ACK: ${message.properties.messageId}`);
          }
        } catch (error) {
          this.logger.error(
            `메시지 처리 실패: ${queueName} | MessageId: ${message.properties.messageId}`,
            error.stack,
          );

          // 재시도 로직
          await this.handleFailedMessage(channel, message, error);
        }
      },
      {
        noAck: options?.noAck ?? false,
        priority: options?.priority,
      },
    );

    this.logger.log(`🎯 Consumer 시작: ${queueName}`);
  }

  /**
   * 실패한 메시지 처리
   */
  private async handleFailedMessage(
    channel: any,
    message: ConsumeMessage,
    error: Error,
  ): Promise<void> {
    const retryCount = message.properties.headers?.['x-retry-count'] || 0;
    const maxRetries = 3;

    if (retryCount < maxRetries) {
      // 재시도
      this.logger.warn(
        `재시도: ${message.properties.messageId} | 시도: ${retryCount + 1}/${maxRetries}`,
      );

      // 원본 큐로 다시 발행 (재시도 카운트 증가)
      await channel.publish(
        message.fields.exchange,
        message.fields.routingKey,
        message.content,
        {
          ...message.properties,
          headers: {
            ...message.properties.headers,
            'x-retry-count': retryCount + 1,
            'x-original-error': error.message,
          },
        },
      );

      // NACK (재큐하지 않음)
      channel.nack(message, false, false);
    } else {
      // 최대 재시도 초과 → Dead Letter Queue로 이동
      this.logger.error(
        `최대 재시도 초과: ${message.properties.messageId} → DLQ`,
      );

      // NACK (requeue = false) → DLX로 자동 이동
      channel.nack(message, false, false);
    }
  }

  /**
   * Dead Letter Queue 소비
   */
  async consumeDLQ(
    dlqName: string,
    handler: MessageHandler,
  ): Promise<void> {
    await this.consume(dlqName, async (data, message) => {
      this.logger.warn(
        `💀 DLQ 메시지 처리: ${dlqName} | MessageId: ${message.properties.messageId}`,
      );

      // 영구 실패 처리 (로깅, 알림, 수동 개입 등)
      await handler(data, message);
    });
  }
}
```

---

### Step 4: Saga 패턴 구현

```typescript
// src/rabbitmq/saga/order-saga.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { RabbitMQProducerService } from '../rabbitmq-producer.service';
import { RabbitMQConsumerService } from '../rabbitmq-consumer.service';

export interface OrderSagaData {
  orderId: number;
  userId: number;
  productId: number;
  quantity: number;
  amount: number;
}

export enum SagaStep {
  ORDER_CREATED = 'order.created',
  INVENTORY_RESERVED = 'inventory.reserved',
  PAYMENT_PROCESSED = 'payment.processed',
  SHIPMENT_STARTED = 'shipment.started',
  SAGA_COMPLETED = 'saga.completed',
}

export enum CompensationStep {
  SHIPMENT_CANCELLED = 'shipment.cancelled',
  PAYMENT_REFUNDED = 'payment.refunded',
  INVENTORY_RELEASED = 'inventory.released',
  ORDER_CANCELLED = 'order.cancelled',
}

@Injectable()
export class OrderSagaService {
  private readonly logger = new Logger(OrderSagaService.name);

  constructor(
    private readonly producer: RabbitMQProducerService,
    private readonly consumer: RabbitMQConsumerService,
  ) {}

  /**
   * Saga 시작
   */
  async startSaga(data: OrderSagaData): Promise<void> {
    this.logger.log(`🎬 Saga 시작: Order ${data.orderId}`);

    try {
      // Step 1: 주문 생성 이벤트
      await this.producer.publishEvent(SagaStep.ORDER_CREATED, {
        ...data,
        sagaId: `saga-${data.orderId}`,
        timestamp: Date.now(),
      });

      this.logger.log(`✅ Saga Step 1 완료: ${SagaStep.ORDER_CREATED}`);
    } catch (error) {
      this.logger.error('Saga 시작 실패', error.stack);
      throw error;
    }
  }

  /**
   * Saga 보상 트랜잭션 (Rollback)
   */
  async compensate(data: OrderSagaData, failedStep: string): Promise<void> {
    this.logger.warn(
      `⚠️  Saga 보상 시작: Order ${data.orderId} | 실패 단계: ${failedStep}`,
    );

    try {
      // 역순으로 보상
      if (failedStep === SagaStep.SHIPMENT_STARTED) {
        await this.producer.publishEvent(CompensationStep.SHIPMENT_CANCELLED, data);
      }

      if (
        failedStep === SagaStep.PAYMENT_PROCESSED ||
        failedStep === SagaStep.SHIPMENT_STARTED
      ) {
        await this.producer.publishEvent(CompensationStep.PAYMENT_REFUNDED, data);
      }

      if (
        failedStep === SagaStep.INVENTORY_RESERVED ||
        failedStep === SagaStep.PAYMENT_PROCESSED ||
        failedStep === SagaStep.SHIPMENT_STARTED
      ) {
        await this.producer.publishEvent(CompensationStep.INVENTORY_RELEASED, data);
      }

      // 항상 주문 취소
      await this.producer.publishEvent(CompensationStep.ORDER_CANCELLED, data);

      this.logger.log(`✅ Saga 보상 완료: Order ${data.orderId}`);
    } catch (error) {
      this.logger.error('Saga 보상 실패', error.stack);
      // 수동 개입 필요 알림
      await this.notifyManualIntervention(data, error);
    }
  }

  /**
   * 수동 개입 알림
   */
  private async notifyManualIntervention(
    data: OrderSagaData,
    error: Error,
  ): Promise<void> {
    await this.producer.publishNotification(
      'manual-intervention',
      {
        orderId: data.orderId,
        error: error.message,
        timestamp: Date.now(),
      },
      10, // 최고 우선순위
    );
  }

  /**
   * Saga Consumer 시작
   */
  async startConsumers(): Promise<void> {
    // Order Created 처리
    await this.consumer.consume(
      'orders-queue',
      async (data) => {
        await this.handleOrderCreated(data);
      },
      { prefetch: 1 }, // 순서 보장을 위해 1개씩
    );

    // Inventory Reserved 처리
    await this.consumer.consume(
      'inventory-queue',
      async (data) => {
        await this.handleInventoryReserved(data);
      },
      { prefetch: 1 },
    );

    // Payment Processed 처리
    await this.consumer.consume(
      'payments-queue',
      async (data) => {
        await this.handlePaymentProcessed(data);
      },
      { prefetch: 1 },
    );

    this.logger.log('🎯 Saga Consumers 시작 완료');
  }

  private async handleOrderCreated(data: any): Promise<void> {
    this.logger.log(`처리: ${SagaStep.ORDER_CREATED}`);

    // 재고 확인 이벤트 발행
    await this.producer.publishEvent(SagaStep.INVENTORY_RESERVED, data);
  }

  private async handleInventoryReserved(data: any): Promise<void> {
    this.logger.log(`처리: ${SagaStep.INVENTORY_RESERVED}`);

    // 결제 처리 이벤트 발행
    await this.producer.publishEvent(SagaStep.PAYMENT_PROCESSED, data);
  }

  private async handlePaymentProcessed(data: any): Promise<void> {
    this.logger.log(`처리: ${SagaStep.PAYMENT_PROCESSED}`);

    // 배송 시작 이벤트 발행
    await this.producer.publishEvent(SagaStep.SHIPMENT_STARTED, data);
  }
}
```

---

### Step 5: RabbitMQ 모듈 통합

```typescript
// src/rabbitmq/rabbitmq.module.ts
import { Module, Global } from '@nestjs/common';
import { RabbitMQConnectionService } from './rabbitmq-connection.service';
import { RabbitMQProducerService } from './rabbitmq-producer.service';
import { RabbitMQConsumerService } from './rabbitmq-consumer.service';
import { OrderSagaService } from './saga/order-saga.service';

@Global()
@Module({
  providers: [
    RabbitMQConnectionService,
    RabbitMQProducerService,
    RabbitMQConsumerService,
    OrderSagaService,
  ],
  exports: [
    RabbitMQConnectionService,
    RabbitMQProducerService,
    RabbitMQConsumerService,
    OrderSagaService,
  ],
})
export class RabbitMQModule {}
```

---

### Step 6: AppModule에 등록

```typescript
// src/app.module.ts
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { RabbitMQModule } from './rabbitmq/rabbitmq.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
    }),
    RabbitMQModule, // RabbitMQ 모듈 등록
    // ... 다른 모듈들
  ],
})
export class AppModule {}
```

---

## 🎯 사용 예제

### 1. 주문 생성 시 이벤트 발행

```typescript
// src/modules/orders/orders.service.ts
import { Injectable } from '@nestjs/common';
import { RabbitMQProducerService } from '../../rabbitmq/rabbitmq-producer.service';
import { OrderSagaService } from '../../rabbitmq/saga/order-saga.service';

@Injectable()
export class OrdersService {
  constructor(
    private readonly producer: RabbitMQProducerService,
    private readonly saga: OrderSagaService,
  ) {}

  async createOrder(data: CreateOrderDto) {
    // 주문 생성
    const order = await this.prisma.order.create({ data });

    // Saga 시작
    await this.saga.startSaga({
      orderId: order.id,
      userId: order.buyerId,
      productId: data.productId,
      quantity: data.quantity,
      amount: order.totalAmount,
    });

    return order;
  }
}
```

### 2. 알림 발송 (우선순위)

```typescript
// src/modules/notifications/notifications.service.ts
@Injectable()
export class NotificationsService {
  constructor(private readonly producer: RabbitMQProducerService) {}

  async sendUrgentNotification(userId: number, message: string) {
    // 긴급 알림 (우선순위 10)
    await this.producer.publishNotification(
      'urgent',
      { userId, message },
      10,
    );
  }

  async sendNormalNotification(userId: number, message: string) {
    // 일반 알림 (우선순위 5)
    await this.producer.publishNotification(
      'normal',
      { userId, message },
      5,
    );
  }
}
```

### 3. Consumer 시작

```typescript
// src/main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { OrderSagaService } from './rabbitmq/saga/order-saga.service';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // Saga Consumers 시작
  const sagaService = app.get(OrderSagaService);
  await sagaService.startConsumers();

  await app.listen(3000);
}

bootstrap();
```

---

## ✅ 검증 및 테스트

### 1. 연결 테스트

```bash
# 애플리케이션 시작
pnpm run start:dev

# 로그 확인
# ✅ RabbitMQ 연결 성공
# ✅ RabbitMQ 초기화 완료
# 🎯 Saga Consumers 시작 완료
```

### 2. RabbitMQ Management UI 확인

```bash
# 브라우저에서 접속
http://localhost:15672

# 계정: rabbit / rabbit123

# 확인 사항:
# - Exchanges: events, commands, events-dlx
# - Queues: orders-queue, payments-queue, notifications-queue 등
# - Bindings: 정상적으로 바인딩되어 있는지
```

### 3. 메시지 발행 테스트

```typescript
// 테스트 엔드포인트
@Get('test/publish')
async testPublish() {
  await this.producer.publishEvent('order.created', {
    orderId: 1,
    userId: 1,
    amount: 10000,
  });

  return { message: 'Event published' };
}
```

---

## 📊 모니터링 및 관리

### 1. RabbitMQ 메트릭 수집

```typescript
// src/rabbitmq/rabbitmq-metrics.service.ts
@Injectable()
export class RabbitMQMetricsService {
  async getQueueMetrics(queueName: string) {
    // RabbitMQ HTTP API 호출
    const response = await axios.get(
      `http://localhost:15672/api/queues/%2F/${queueName}`,
      {
        auth: {
          username: 'rabbit',
          password: 'rabbit123',
        },
      },
    );

    return {
      messages: response.data.messages,
      messagesReady: response.data.messages_ready,
      messagesUnacknowledged: response.data.messages_unacknowledged,
      consumers: response.data.consumers,
    };
  }
}
```

### 2. 헬스체크

```typescript
// src/health/rabbitmq-health.indicator.ts
import { Injectable } from '@nestjs/common';
import { HealthIndicator, HealthIndicatorResult } from '@nestjs/terminus';
import { RabbitMQConnectionService } from '../rabbitmq/rabbitmq-connection.service';

@Injectable()
export class RabbitMQHealthIndicator extends HealthIndicator {
  constructor(
    private readonly connectionService: RabbitMQConnectionService,
  ) {
    super();
  }

  async isHealthy(key: string): Promise<HealthIndicatorResult> {
    const isConnected = this.connectionService.isConnected();

    if (isConnected) {
      return this.getStatus(key, true);
    }

    return this.getStatus(key, false, {
      message: 'RabbitMQ connection is down',
    });
  }
}
```

---

## 🚀 다음 단계

1. **Week 3**: 기본 AMQP 구현 완료
2. **Week 4**: Dead Letter Queue 및 재시도 로직 테스트
3. **Week 9**: Saga 패턴 실전 적용 (주문/결제 워크플로우)

---

**문서 버전**: v1.0
**최종 업데이트**: 2025-10-15
**작성자**: 개발팀
